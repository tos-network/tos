#!/usr/bin/env python3
"""
TOS AI Mining Complete Workflow Demo
Demonstrates the complete AI mining data flow: task publishing â†’ answer submission â†’ validation â†’ reward distribution
"""

import json
import urllib.request
import time
import hashlib
import random
import sys
from datetime import datetime

class TOSAIMiningDemo:
    def __init__(self, daemon_url: str = "http://127.0.0.1:8080"):
        self.daemon_url = daemon_url
        self.task_publisher_id = "publisher_001"
        self.miner_id = "miner_001"
        self.validator_id = "validator_001"

    def rpc_call(self, method: str, params: dict = None) -> dict:
        """Call RPC method"""
        payload = {
            "jsonrpc": "2.0",
            "method": method,
            "id": random.randint(1, 10000)
        }
        if params:
            payload["params"] = params

        data = json.dumps(payload).encode('utf-8')
        req = urllib.request.Request(
            f"{self.daemon_url}/json_rpc",
            data=data,
            headers={'Content-Type': 'application/json'}
        )

        try:
            with urllib.request.urlopen(req, timeout=30) as response:
                result = json.loads(response.read().decode('utf-8'))

            if "error" in result:
                print(f"âŒ RPC Error: {result['error']}")
                return {}
            return result.get("result", {})
        except Exception as e:
            print(f"âŒ Network Error: {e}")
            return {}

    def generate_task_id(self) -> str:
        """Generate task ID"""
        timestamp = str(int(time.time()))
        random_part = str(random.randint(1000, 9999))
        task_data = f"task_{timestamp}_{random_part}"
        return hashlib.sha256(task_data.encode()).hexdigest()

    def generate_answer_hash(self, answer_content: str) -> str:
        """Generate hash of answer content"""
        return hashlib.sha256(answer_content.encode('utf-8')).hexdigest()

    def step1_publish_task(self) -> tuple:
        """Step 1: Publish AI mining task"""
        print("\n" + "="*60)
        print("ğŸš€ Step 1: Publish AI Mining Task")
        print("="*60)

        # Generate task parameters
        task_id = self.generate_task_id()
        reward_amount = 2000000  # 2M nanoTOS = 0.002 TOS
        deadline = int(time.time()) + 3600  # Deadline in 1 hour

        # Task description (actual content, 10-2048 bytes)
        task_description = """
Analyze the given Rust code snippet, identify performance bottlenecks and provide optimization suggestions:

```rust
fn bubble_sort(arr: &mut [i32]) {
    let n = arr.len();
    for i in 0..n {
        for j in 0..n-1-i {
            if arr[j] > arr[j+1] {
                arr.swap(j, j+1);
            }
        }
    }
}
```

Requirements:
1. Identify algorithm complexity issues
2. Provide at least 3 optimization approaches
3. Estimate performance improvement percentages
4. Provide optimized code examples
        """.strip()

        print(f"ğŸ“‹ Task ID: {task_id[:16]}...")
        print(f"ğŸ’° Reward Amount: {reward_amount:,} nanoTOS")
        print(f"â° Deadline: {datetime.fromtimestamp(deadline)}")
        print(f"ğŸ“ Task Description Length: {len(task_description)} bytes")
        print(f"ğŸ’¸ Content Storage Fee: {len(task_description) * 0.001:.3f} TOS")

        # Simulate task publishing transaction (should be sent via wallet in practice)
        task_data = {
            "task_id": task_id,
            "publisher_id": self.task_publisher_id,
            "reward_amount": reward_amount,
            "difficulty": "Intermediate",
            "deadline": deadline,
            "description": task_description,
            "created_at": int(time.time())
        }

        print("âœ… Task published successfully!")
        print(f"ğŸ“Š Gas fee calculation:")
        print(f"   - Base transaction fee: 2,500 nanoTOS (Devnet)")
        print(f"   - Content storage fee: {len(task_description):,} * 1,000,000 = {len(task_description) * 1_000_000:,} nanoTOS")
        print(f"   - Total fee: ~{(2500 + len(task_description) * 1_000_000):,} nanoTOS")

        return task_id, task_data

    def step2_submit_answer(self, task_id: str, task_data: dict) -> tuple:
        """Step 2: Miner submits task answer"""
        print("\n" + "="*60)
        print("ğŸ¤– Step 2: AI Miner Analyzes and Submits Answer")
        print("="*60)

        print(f"ğŸ” Miner analyzing task: {task_id[:16]}...")
        time.sleep(2)  # Simulate AI computation time

        # Generate AI answer content (should be generated by AI model in practice)
        answer_content = """
## Performance Analysis Report

### 1. Algorithm Complexity Issues
The current bubble sort has O(nÂ²) time complexity and O(1) space complexity. Main performance bottlenecks:
- Nested loops causing quadratic time complexity
- Full comparison in each round even when array is already sorted
- Frequent element swap operations

### 2. Optimization Approaches

**Approach 1: Early Termination Optimization**
```rust
fn optimized_bubble_sort(arr: &mut [i32]) {
    let n = arr.len();
    for i in 0..n {
        let mut swapped = false;
        for j in 0..n-1-i {
            if arr[j] > arr[j+1] {
                arr.swap(j, j+1);
                swapped = true;
            }
        }
        if !swapped { break; }
    }
}
```
Expected improvement: Best case from O(nÂ²) to O(n)

**Approach 2: Use Quick Sort**
```rust
fn quick_sort(arr: &mut [i32]) {
    if arr.len() <= 1 { return; }
    let pivot = partition(arr);
    quick_sort(&mut arr[0..pivot]);
    quick_sort(&mut arr[pivot+1..]);
}
```
Expected improvement: Average complexity to O(n log n), 75-90% improvement

**Approach 3: Use Rust Standard Library**
```rust
fn std_sort(arr: &mut [i32]) {
    arr.sort_unstable();
}
```
Expected improvement: Highly optimized TimSort algorithm, 90%+ performance gain

### 3. Performance Benchmarking Recommendations
Recommend testing performance differences on arrays of 1000, 10000, 100000 elements.
        """.strip()

        # Generate answer hash
        answer_hash = self.generate_answer_hash(answer_content)
        stake_amount = 100000  # 100K nanoTOS stake

        print(f"ğŸ§  AI analysis completed!")
        print(f"ğŸ“„ Answer content length: {len(answer_content)} bytes")
        print(f"ğŸ” Answer hash: {answer_hash[:16]}...")
        print(f"ğŸ’° Stake amount: {stake_amount:,} nanoTOS")
        print(f"ğŸ’¸ Answer storage fee: {len(answer_content) * 0.001:.3f} TOS")

        # Simulate answer submission transaction
        answer_data = {
            "task_id": task_id,
            "miner_id": self.miner_id,
            "answer_content": answer_content,  # v1.1.0 new feature: direct answer content storage
            "answer_hash": answer_hash,
            "stake_amount": stake_amount,
            "submitted_at": int(time.time())
        }

        print("âœ… Answer submitted successfully!")
        print(f"ğŸ“Š Gas fee calculation:")
        print(f"   - Base transaction fee: 1,875 nanoTOS (Devnet)")
        print(f"   - Answer storage fee: {len(answer_content):,} * 1,000,000 = {len(answer_content) * 1_000_000:,} nanoTOS")
        print(f"   - Total fee: ~{(1875 + len(answer_content) * 1_000_000):,} nanoTOS")

        return answer_hash, answer_data

    def step3_validate_answer(self, task_id: str, answer_hash: str, answer_data: dict) -> dict:
        """Step 3: Validate answer content"""
        print("\n" + "="*60)
        print("ğŸ” Step 3: Validate Answer Content (v1.1.0 new feature)")
        print("="*60)

        print(f"ğŸ‘¨â€âš–ï¸ Validators can see actual answer content (not just hash)")
        print(f"ğŸ“‹ Validating task: {task_id[:16]}...")
        print(f"ğŸ” Answer ID: {answer_hash[:16]}...")

        # Validators can see answer content for evaluation
        answer_content = answer_data["answer_content"]
        print(f"ğŸ“– Answer content preview: {answer_content[:100]}...")

        time.sleep(3)  # Simulate validation process

        # Validation scoring based on actual content
        validation_score = 0

        # Check answer quality metrics
        print("\nğŸ” Content Quality Assessment:")

        # 1. Length check
        if len(answer_content) >= 500:
            validation_score += 20
            print("âœ… Adequate answer length (+20 points)")
        else:
            print("âš ï¸ Answer too short")

        # 2. Technical content check
        tech_keywords = ["algorithm", "complexity", "optimization", "performance", "code"]
        tech_score = sum(10 for keyword in tech_keywords if keyword.lower() in answer_content.lower())
        validation_score += min(tech_score, 30)
        print(f"âœ… Technical keyword coverage (+{min(tech_score, 30)} points)")

        # 3. Code example check
        if "```rust" in answer_content:
            validation_score += 25
            print("âœ… Contains code examples (+25 points)")

        # 4. Structured content check
        if "###" in answer_content and "**" in answer_content:
            validation_score += 15
            print("âœ… Structured answer (+15 points)")

        # 5. Specific data check
        if any(char.isdigit() for char in answer_content):
            validation_score += 10
            print("âœ… Contains specific data (+10 points)")

        # Ensure score is within 0-100 range
        validation_score = min(validation_score, 100)

        print(f"\nğŸ“Š Final validation score: {validation_score}/100")

        # Simulate validation transaction
        validation_data = {
            "task_id": task_id,
            "answer_id": answer_hash,
            "validator_id": self.validator_id,
            "validation_score": validation_score,
            "validated_at": int(time.time()),
            "validation_details": {
                "content_length": len(answer_content),
                "technical_depth": "High",
                "code_examples": True,
                "structure_quality": "Good"
            }
        }

        print("âœ… Answer validation completed!")
        print(f"ğŸ“Š Validation transaction fee: 2,187 nanoTOS (Devnet)")

        return validation_data

    def step4_calculate_rewards(self, task_data: dict, answer_data: dict, validation_data: dict) -> dict:
        """Step 4: Calculate and distribute rewards"""
        print("\n" + "="*60)
        print("ğŸ’° Step 4: Calculate and Distribute Rewards")
        print("="*60)

        base_reward = task_data["reward_amount"]  # 2M nanoTOS
        validation_score = validation_data["validation_score"]

        print(f"ğŸ’ Base reward pool: {base_reward:,} nanoTOS")
        print(f"ğŸ“Š Validation score: {validation_score}%")

        # Calculate actual reward based on validation score
        efficiency_ratio = validation_score / 100.0
        actual_reward = int(base_reward * efficiency_ratio)

        print(f"âš¡ Efficiency ratio: {efficiency_ratio:.2%}")
        print(f"ğŸ¯ Actual reward: {actual_reward:,} nanoTOS")

        # Reward distribution (according to distribution ratios in documentation)
        miner_share = 0.70      # 70% to miner
        validator_share = 0.20  # 20% to validator
        network_share = 0.10    # 10% to network

        miner_reward = int(actual_reward * miner_share)
        validator_reward = int(actual_reward * validator_share)
        network_fee = actual_reward - miner_reward - validator_reward

        print(f"\nğŸ’¸ Reward distribution details:")
        print(f"ğŸ¤– Miner reward (70%): {miner_reward:,} nanoTOS")
        print(f"ğŸ” Validator reward (20%): {validator_reward:,} nanoTOS")
        print(f"ğŸŒ Network fee (10%): {network_fee:,} nanoTOS")

        # Calculate total cost-benefit
        total_gas_cost = (
            2500 + len(task_data["description"]) * 1_000_000 +  # Task publishing
            1875 + len(answer_data["answer_content"]) * 1_000_000 +  # Answer submission
            2187  # Validation
        )

        print(f"\nğŸ“ˆ Economic metrics:")
        print(f"ğŸ“¤ Total gas cost: {total_gas_cost:,} nanoTOS ({total_gas_cost/1_000_000_000:.3f} TOS)")
        print(f"ğŸ’° Total reward distributed: {actual_reward:,} nanoTOS ({actual_reward/1_000_000_000:.3f} TOS)")
        print(f"ğŸ“Š Reward/cost ratio: {actual_reward/total_gas_cost:.1f}x")

        reward_data = {
            "task_id": task_data["task_id"],
            "base_reward": base_reward,
            "validation_score": validation_score,
            "efficiency_ratio": efficiency_ratio,
            "actual_reward": actual_reward,
            "distribution": {
                "miner": {"id": self.miner_id, "amount": miner_reward},
                "validator": {"id": self.validator_id, "amount": validator_reward},
                "network": {"amount": network_fee}
            },
            "economics": {
                "total_gas_cost": total_gas_cost,
                "reward_cost_ratio": actual_reward / total_gas_cost
            },
            "distributed_at": int(time.time())
        }

        print("âœ… Reward calculation and distribution completed!")

        return reward_data

    def run_complete_workflow(self):
        """Run complete AI mining workflow"""
        print("ğŸš€ TOS AI Mining Complete Workflow Demo")
        print("ğŸ¯ Demonstrates complete data flow of v1.1.0 answer content storage mechanism")
        print("â±ï¸ Start time:", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

        try:
            # Check daemon connection
            print("\nğŸ”Œ Checking TOS daemon connection...")
            daemon_info = self.rpc_call("get_info")
            if daemon_info:
                print(f"âœ… Connection successful: TOS {daemon_info.get('version', 'Unknown')} ({daemon_info.get('network', 'Unknown')})")
            else:
                print("âŒ Unable to connect to TOS daemon")
                return

            # Execute complete workflow
            task_id, task_data = self.step1_publish_task()
            answer_hash, answer_data = self.step2_submit_answer(task_id, task_data)
            validation_data = self.step3_validate_answer(task_id, answer_hash, answer_data)
            reward_data = self.step4_calculate_rewards(task_data, answer_data, validation_data)

            # Display final summary
            print("\n" + "="*60)
            print("ğŸ‰ AI Mining Workflow Completion Summary")
            print("="*60)

            print(f"ğŸ“‹ Task ID: {task_id[:16]}...")
            print(f"ğŸ¤– Miner: {self.miner_id}")
            print(f"ğŸ” Validator: {self.validator_id}")
            print(f"ğŸ“Š Validation score: {validation_data['validation_score']}%")
            print(f"ğŸ’° Miner received: {reward_data['distribution']['miner']['amount']:,} nanoTOS")
            print(f"ğŸ” Validator received: {reward_data['distribution']['validator']['amount']:,} nanoTOS")
            print(f"âš¡ Overall efficiency: {reward_data['efficiency_ratio']:.1%}")

            # Save complete workflow data
            workflow_data = {
                "workflow_id": f"demo_{int(time.time())}",
                "timestamp": datetime.now().isoformat(),
                "version": "v1.1.0",
                "task": task_data,
                "answer": answer_data,
                "validation": validation_data,
                "rewards": reward_data
            }

            with open(f"ai_mining_workflow_{int(time.time())}.json", "w", encoding="utf-8") as f:
                json.dump(workflow_data, f, indent=2, ensure_ascii=False)

            print(f"ğŸ’¾ Complete workflow data saved")
            print("âœ… Demo completed!")

        except Exception as e:
            print(f"âŒ Workflow execution failed: {e}")
            import traceback
            traceback.print_exc()

def main():
    """Main function"""
    demo = TOSAIMiningDemo()
    demo.run_complete_workflow()

if __name__ == "__main__":
    main()