# TOS Multi-Client Alignment: Technical Scheme

## Overview

This document provides the technical specifications for the Hybrid Mode multi-client alignment methodology. It includes Critical Path Specifications, Extended Test Vector Schema, and Differential Testing Architecture.

**Companion Document**: See `MULTI_CLIENT_ALIGNMENT.md` for methodology overview and implementation strategy.

---

## Table of Contents

1. [Reference Implementation Model](#1-reference-implementation-model)
2. [Critical Path Specifications](#2-critical-path-specifications)
   - [A. Wire Format Specification](#2a-wire-format-specification)
   - [B. Hash Algorithms](#2b-hash-algorithms)
   - [C. BlockDAG Execution Order Algorithm](#2c-blockdag-execution-order-algorithm)
   - [D. Failed Transaction Semantics](#2d-failed-transaction-semantics)
   - [E. Nonce Handling Rules](#2e-nonce-handling-rules)
   - [F. State Digest Specification](#2f-state-digest-specification)
   - [G. Error Codes](#2g-error-codes)
3. [Extended Test Vector Schema](#3-extended-test-vector-schema)
4. [Differential Testing Architecture](#4-differential-testing-architecture)
5. [Implementation Milestones](#5-implementation-milestones)

---

## 1. Reference Implementation Model

### 1.1 Authority Hierarchy

```
┌─────────────────────────────────────────────────────────────┐
│                    TOS Rust Implementation                   │
│                   (Authoritative Source)                     │
│                                                              │
│  • Defines correct behavior for all protocol operations      │
│  • Generates test vectors from actual execution              │
│  • Resolves ambiguities by definition                        │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ generates
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Critical Path Specs                       │
│                   (Normative Documents)                      │
│                                                              │
│  • Human-readable specifications                             │
│  • Derived from Rust implementation                          │
│  • Updated when Rust behavior changes                        │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ informs
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Test Vectors (YAML)                       │
│                   (Verification Artifacts)                   │
│                                                              │
│  • Generated by Rust implementation                          │
│  • Consumed by all client implementations                    │
│  • Defines expected outputs for given inputs                 │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ verified by
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Client Implementations                    │
│                   (Avatar C, Future Go, etc.)               │
│                                                              │
│  • Implement protocol according to specs                     │
│  • Verify against test vectors                               │
│  • Report divergences for resolution                         │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 Divergence Resolution

When implementations produce different results:

1. **Vector-covered case**: Rust output is correct. Other client must fix.
2. **Uncovered case**: Add vector from Rust, then other client must fix.
3. **Rust bug discovered**: Fix Rust, regenerate vectors, update all clients.

**Process**:
```
Divergence detected
        │
        ▼
┌───────────────────┐     Yes     ┌────────────────────┐
│ Is this a known   │────────────►│ Other client fixes │
│ Rust behavior?    │             │ to match Rust      │
└───────────────────┘             └────────────────────┘
        │ No
        ▼
┌───────────────────┐     Yes     ┌────────────────────┐
│ Is Rust behavior  │────────────►│ Fix Rust, regen    │
│ clearly wrong?    │             │ vectors, update all│
└───────────────────┘             └────────────────────┘
        │ No
        ▼
┌───────────────────┐
│ Rust is correct   │
│ by definition     │
└───────────────────┘
```

---

## 2. Critical Path Specifications

Critical paths are protocol behaviors where divergence would break consensus. All clients MUST implement these identically.

### 2.A Wire Format Specification

#### 2.A.1 Overview

All TOS transactions are serialized to a canonical binary format for:
- Network transmission
- Transaction ID computation
- Signature generation and verification
- Persistent storage

#### 2.A.2 Primitive Type Encoding

| Type | Size | Encoding | Notes |
|------|------|----------|-------|
| `u8` | 1 byte | Big-endian | Unsigned 8-bit integer |
| `u16` | 2 bytes | Big-endian | Unsigned 16-bit integer |
| `u32` | 4 bytes | Big-endian | Unsigned 32-bit integer |
| `u64` | 8 bytes | Big-endian | Unsigned 64-bit integer |
| `u128` | 16 bytes | Big-endian | Unsigned 128-bit integer |
| `i64` | 8 bytes | Big-endian (two's complement) | Signed 64-bit integer |
| `bool` | 1 byte | `0x00` = false, `0x01` = true | No other values allowed |

**Example: u64 encoding**
```
Value: 1000000 (0xF4240)
Wire:  00 00 00 00 00 0F 42 40  (8 bytes, big-endian)
```

#### 2.A.3 Variable-Length Encoding

**Length-Prefixed Bytes** (for arbitrary data):
```
┌──────────────────┬─────────────────────────────────┐
│  Length (u32)    │  Data (length bytes)            │
│  4 bytes BE      │  variable                       │
└──────────────────┴─────────────────────────────────┘
```

**Example: "Hello" (5 bytes)**
```
Wire: 00 00 00 05 48 65 6C 6C 6F
      └─ length ─┘ └── data ──┘
```

**Fixed-Size Arrays** (for known sizes):
- No length prefix
- Elements concatenated directly
- Size known from context (e.g., hash = 32 bytes, pubkey = 33 bytes)

#### 2.A.4 Optional Fields

Optional fields are encoded with a presence byte:

```
┌─────────────────┬─────────────────────────────────┐
│  Present (u8)   │  Value (if present = 0x01)      │
│  0x00 or 0x01   │  type-specific encoding         │
└─────────────────┴─────────────────────────────────┘
```

**Example: Optional u64**
```
None:    00
Some(5): 01 05 00 00 00 00 00 00 00
```

#### 2.A.5 Collections

**Vectors** (variable-length lists):
```
┌──────────────────┬─────────────────────────────────┐
│  Count (u32)     │  Elements (count × element_size)│
│  4 bytes BE      │  concatenated                   │
└──────────────────┴─────────────────────────────────┘
```

**Maps** (key-value pairs):
```
┌──────────────────┬─────────────────────────────────────────────┐
│  Count (u32)     │  Entries (count × (key_size + value_size)) │
│  4 bytes BE      │  sorted by key, concatenated               │
└──────────────────┴─────────────────────────────────────────────┘
```

**CRITICAL**: Map entries MUST be sorted by key in lexicographic order to ensure canonical encoding.

#### 2.A.6 Account Address Encoding

TOS uses 32-byte compressed public keys with Bech32 encoding for human-readable addresses:

**Internal Representation** (32 bytes):
```
┌─────────────────────────────────────────────────────┐
│  CompressedPublicKey (32 bytes)                     │
│  Ristretto255 compressed point                      │
└─────────────────────────────────────────────────────┘
```

**Human-Readable Format** (Bech32):
| Network | Prefix | Example |
|---------|--------|---------|
| Mainnet | `tos1` | `tos1abc123...xyz789` |
| Testnet | `tst1` | `tst1abc123...xyz789` |

**Encoding**:
- Raw bytes: 32-byte Ristretto255 compressed public key
- Display: Bech32-encoded with network prefix
- Checksum: Bech32 includes error-detection checksum

**Example**:
```
Raw (32 bytes): 50bb83534f8209a9584a5972c8fa9ad3c25cbf030dffa1099213bcdb6a8c413c
Bech32 (tst1): tst12zacnuun3lkv5kxzn2jy8l28d0zft7rqhyxlz2v6h6u23xmruy7sqm0d38u
```

#### 2.A.7 Transaction Envelope

All transactions share a common envelope structure:

```
┌─────────────────────────────────────────────────────────────┐
│                    Transaction Envelope                      │
├─────────────────┬───────────────────────────────────────────┤
│  version (u8)   │  Protocol version (currently 0x01)        │
├─────────────────┼───────────────────────────────────────────┤
│  type (u8)      │  Transaction type (0-255)                 │
├─────────────────┼───────────────────────────────────────────┤
│  sender (32)    │  Sender's compressed public key           │
├─────────────────┼───────────────────────────────────────────┤
│  nonce (u64)    │  Sender's transaction sequence number     │
├─────────────────┼───────────────────────────────────────────┤
│  fee (u64)      │  Fee in base units                        │
├─────────────────┼───────────────────────────────────────────┤
│  timestamp (u64)│  Unix timestamp in milliseconds           │
├─────────────────┼───────────────────────────────────────────┤
│  payload        │  Type-specific payload (variable)         │
├─────────────────┼───────────────────────────────────────────┤
│  signature      │  Signature over envelope (64-65 bytes)    │
└─────────────────┴───────────────────────────────────────────┘
```

**Envelope header size**: 1 + 1 + 32 + 8 + 8 + 8 = **58 bytes** (fixed)

#### 2.A.8 Transaction Type Catalog

| Type | Name | Payload Size | Description |
|------|------|--------------|-------------|
| 0 | Burn | 8 | Destroy tokens |
| 1 | Transfer | 29 | Send tokens to address |
| 2 | TransferMulti | Variable | Send to multiple addresses |
| 3 | Genesis | Variable | Network initialization (block 0 only) |
| 4 | Coinbase | 0 | Block reward (block producer only) |
| 5 | EnergyBuy | 8 | Convert tokens to energy |
| 6 | EnergyRefund | 8 | Convert energy back to tokens |
| 7 | Delegate | 29 | Delegate energy to address |
| 8 | Undelegate | 29 | Remove energy delegation |
| 9 | SetKyc | Variable | Set KYC verification level |
| 10 | RevokeKyc | 21 | Revoke KYC verification |
| 11 | RenewKyc | Variable | Extend KYC expiration |
| 12 | RegisterCommittee | Variable | Register as KYC committee |
| 13 | DeregisterCommittee | 0 | Unregister KYC committee |
| 14 | UpdateCommittee | Variable | Update committee parameters |
| 15 | BootstrapKyc | Variable | Initial KYC setup |
| 16 | KycApprove | Variable | Committee approves KYC |
| 17 | KycReject | Variable | Committee rejects KYC |
| 24 | EscrowCreate | Variable | Create escrow |
| 25 | EscrowDeposit | Variable | Deposit to escrow |
| 26 | EscrowRelease | Variable | Release escrow funds |
| 27 | EscrowRefund | Variable | Refund escrow |
| 28 | EscrowChallenge | Variable | Challenge escrow release |
| 29 | EscrowVerdict | Variable | Arbitrator verdict |
| 30 | EscrowAppeal | Variable | Appeal verdict |
| 31 | EscrowResolve | Variable | Final resolution |
| 32 | EscrowCancel | Variable | Cancel escrow |
| 40 | TNSRegister | Variable | Register domain name |
| 41 | TNSTransfer | Variable | Transfer domain |
| 42 | TNSUpdate | Variable | Update domain record |
| 43 | TNSExtend | Variable | Extend domain registration |
| 44 | TNSRelease | Variable | Release domain |
| 50 | ContractDeploy | Variable | Deploy smart contract |
| 51 | ContractCall | Variable | Call contract method |
| 52 | ContractUpgrade | Variable | Upgrade contract |
| 60 | ReferralRegister | Variable | Register referral code |
| 61 | ReferralActivate | Variable | Activate with referral |
| 62 | ReferralClaim | Variable | Claim referral rewards |
| 70 | AgentCreate | Variable | Create agent account |
| 71 | AgentUpdate | Variable | Update agent parameters |
| 72 | AgentRevoke | Variable | Revoke agent permissions |
| 80 | MultiSigCreate | Variable | Create multisig account |
| 81 | MultiSigPropose | Variable | Propose transaction |
| 82 | MultiSigApprove | Variable | Approve proposal |
| 83 | MultiSigExecute | Variable | Execute approved proposal |
| 84 | MultiSigReject | Variable | Reject proposal |
| 90 | UnoTransfer | Variable | Private transfer (ZK) |
| 91 | UnoMint | Variable | Mint private tokens |
| 92 | UnoBurn | Variable | Burn private tokens |

#### 2.A.9 Wire Format Examples

**Transfer Transaction (Type 1)**

Payload structure:
```
┌─────────────────┬───────────────────────────────────────────┐
│  recipient (32) │  Recipient's compressed public key        │
├─────────────────┼───────────────────────────────────────────┤
│  amount (u64)   │  Transfer amount in base units            │
└─────────────────┴───────────────────────────────────────────┘
```

Complete wire format (without signature):
```
Offset  Size  Field         Example Value
------  ----  -----         -------------
0       1     version       01
1       1     type          01 (Transfer)
2       32    sender        <32 bytes compressed pubkey>
34      8     nonce         00 00 00 00 00 00 00 05 (5, big-endian)
42      8     fee           00 00 00 00 00 00 00 01 (1, big-endian)
50      8     timestamp     00 00 01 89 12 34 56 78 (ms since epoch)
58      32    recipient     <32 bytes compressed pubkey>
90      8     amount        00 00 00 00 00 00 00 64 (100, big-endian)
------
Total: 98 bytes (+ signature)
```

**Burn Transaction (Type 0)**

Payload structure:
```
┌─────────────────┬───────────────────────────────────────────┐
│  amount (u64)   │  Amount to burn in base units             │
└─────────────────┴───────────────────────────────────────────┘
```

Complete wire format:
```
Offset  Size  Field         Example Value
------  ----  -----         -------------
0       1     version       01
1       1     type          00 (Burn)
2       32    sender        <32 bytes compressed pubkey>
34      8     nonce         00 00 00 00 00 00 00 05 (5, big-endian)
42      8     fee           00 00 00 00 00 00 00 01 (1, big-endian)
50      8     timestamp     00 00 01 89 12 34 56 78 (ms since epoch)
58      8     amount        00 00 00 00 00 00 03 E8 (1000, big-endian)
------
Total: 66 bytes (+ signature)
```

---

### 2.B Hash Algorithms

#### 2.B.1 Hash Algorithm Selection

TOS uses different hash algorithms for different purposes:

| Purpose | Algorithm | Output Size | Rationale |
|---------|-----------|-------------|-----------|
| Transaction ID (txid) | BLAKE3 | 32 bytes | Fast, modern, parallelizable |
| Signature Hash (sig_hash) | SHA3-512 | 64 bytes | High security margin for signatures |
| Address Hash | SHA256 + RIPEMD160 | 20 bytes | Bitcoin-compatible, compact |
| State Root | SHA3-256 | 32 bytes | Merkle tree root |
| Block Hash | BLAKE3 | 32 bytes | Same as txid for consistency |

#### 2.B.2 Transaction ID Computation

The transaction ID (txid) is computed as:

```
txid = BLAKE3(envelope_without_signature)
```

**Input**: Transaction envelope bytes from offset 0 to end of payload (excluding signature)

**Example**:
```
Envelope (76 bytes, no sig): 01 01 01 ... (transfer)
txid = BLAKE3(envelope)
     = 7a3b4c5d... (32 bytes)
```

**CRITICAL**: The signature is NOT included in txid computation. This allows signature malleability without changing txid.

#### 2.B.3 Signature Hash Computation

The signature hash (sig_hash) is what gets signed:

```
sig_hash = SHA3-512(envelope_without_signature)
```

**Input**: Same as txid (envelope without signature)

**Why SHA3-512?**
- 512-bit output provides extra security margin
- Different algorithm than txid prevents related-key attacks
- SHA3 is more conservative choice for cryptographic commitments

#### 2.B.4 Address Derivation

TOS uses Ristretto255 compressed public keys with Bech32 encoding:

**Internal Representation**:
```
address = CompressedPublicKey (32 bytes Ristretto255 point)
```

**Human-Readable Format** (Bech32):
```
display_address = Bech32Encode(prefix, compressed_pubkey)
```

**Steps**:
1. Generate Ristretto255 keypair from secret key
2. Compress public key to 32 bytes (Ristretto compressed point)
3. For display: Bech32-encode with network prefix (tos1/tst1)
4. Total internal size: 32 bytes

**Example**:
```
Secret Key:                (32 bytes scalar)
Public Key (Ristretto):    (32 bytes compressed point)
Raw hex:                   50bb83534f8209a9584a5972c8fa9ad3c25cbf030dffa1099213bcdb6a8c413c
Bech32 (testnet):          tst12zacnuun3lkv5kxzn2jy8l28d0zft7rqhyxlz2v6h6u23xmruy7sqm0d38u
```

#### 2.B.5 State Root Computation

The state root is a Merkle tree root of account states:

```
state_root = SHA3-256(MerkleTree(sorted_accounts))
```

**Account state hash**:
```
account_hash = SHA3-256(address || balance || nonce || energy || data_hash)
```

**Merkle tree**:
- Accounts sorted by address (lexicographic)
- Binary Merkle tree with SHA3-256
- Leaves are account hashes
- Empty tree root = SHA3-256("")

---

### 2.C BlockDAG Execution Order Algorithm

#### 2.C.1 Overview

TOS uses a BlockDAG (Directed Acyclic Graph) structure where blocks can have multiple parents. This requires a deterministic algorithm to order transactions for execution.

#### 2.C.2 Block Structure

```
┌─────────────────────────────────────────────────────────────┐
│                         Block Header                         │
├─────────────────┬───────────────────────────────────────────┤
│  version (u8)   │  Block format version                     │
├─────────────────┼───────────────────────────────────────────┤
│  height (u64)   │  Block height (max parent height + 1)     │
├─────────────────┼───────────────────────────────────────────┤
│  timestamp (u64)│  Block creation time (ms)                 │
├─────────────────┼───────────────────────────────────────────┤
│  parents        │  List of parent block hashes (1-N)        │
├─────────────────┼───────────────────────────────────────────┤
│  tx_root (32)   │  Merkle root of transactions              │
├─────────────────┼───────────────────────────────────────────┤
│  state_root (32)│  State root after block execution         │
├─────────────────┼───────────────────────────────────────────┤
│  difficulty     │  Proof-of-work difficulty                 │
├─────────────────┼───────────────────────────────────────────┤
│  nonce (u64)    │  PoW nonce                                │
└─────────────────┴───────────────────────────────────────────┘
```

#### 2.C.3 DAG Ordering Algorithm (Cumulative Difficulty)

TOS uses a cumulative-difficulty-based topological ordering (NOT GHOSTDAG):

**Step 1: Initialize Processing Stack**

```python
def generate_full_order(target_block):
    """
    Generate deterministic total ordering from target block.
    Based on: daemon/src/core/blockchain.rs:2232-2326
    """
    stack = deque()
    processed = set()
    ordered = []

    stack.append(target_block.hash)
```

**Step 2: Traverse DAG with Cumulative Difficulty Sorting**

```python
    while stack:
        current_hash = stack.pop()

        if current_hash in processed:
            continue

        current_block = get_block(current_hash)
        tips = current_block.tips

        # Sort tips by cumulative difficulty (ascending)
        scores = [(tip, get_cumulative_difficulty(tip)) for tip in tips]
        scores.sort(key=lambda x: x[1])  # Ascending order

        processed.add(current_hash)
        ordered.append(current_hash)

        # Push tips to stack (higher difficulty processed last = executed first)
        for tip_hash, _ in scores:
            if tip_hash not in processed:
                stack.append(tip_hash)

    return ordered
```

**Step 3: Assign TopoHeight**

```python
def assign_topoheight(ordered, base_topoheight):
    """
    Assign sequential topoheight to ordered blocks.
    """
    for i, block_hash in enumerate(ordered):
        topoheight = base_topoheight + i
        store_topoheight(block_hash, topoheight)
```

**Step 3: Order Transactions Within Blocks**

Within each block, transactions are ordered by:
1. Transaction type priority (Coinbase first)
2. Fee (higher fee first)
3. Nonce (lower nonce first for same sender)
4. Transaction ID (lexicographic, as tiebreaker)

```python
def order_transactions(block):
    """
    Order transactions within a single block.
    """
    return sorted(block.transactions, key=lambda tx: (
        0 if tx.type == COINBASE else 1,  # Coinbase first
        -tx.fee,                           # Higher fee first
        tx.sender,                         # Group by sender
        tx.nonce,                          # Lower nonce first
        tx.txid                            # Tiebreaker
    ))
```

#### 2.C.4 Height Calculation

Block height is deterministic:

```python
def calculate_height(block):
    """
    Block height = max(parent heights) + 1
    Genesis block has height 0.
    """
    if not block.parents:
        return 0  # Genesis
    return max(parent.height for parent in block.parents) + 1
```

#### 2.C.5 Fork Choice Rule

When multiple tips exist, select the one with highest cumulative difficulty:

```python
def select_tip(candidates):
    """
    Select the best tip (chain head).
    """
    return max(candidates, key=lambda b: (
        b.cumulative_difficulty,  # Primary: most work
        b.blue_score,             # Secondary: most blue blocks
        b.hash                    # Tertiary: lowest hash (tiebreaker)
    ))
```

**Cumulative difficulty**:
```python
def cumulative_difficulty(block):
    """
    Sum of all difficulties in the blue set.
    """
    return sum(b.difficulty for b in block.blue_set)
```

---

### 2.D Failed Transaction Semantics

#### 2.D.1 Overview

When a transaction fails during execution, the system must handle:
- Fee deduction
- State rollback
- Error recording
- Nonce advancement

#### 2.D.2 Failure Categories

| Category | Fee Charged | Nonce Advanced | State Changes |
|----------|-------------|----------------|---------------|
| **Pre-validation failure** | No | No | None |
| **Execution failure** | Yes | Yes | Rolled back |
| **Partial execution** | Yes | Yes | Partial (see below) |

**Pre-validation failures** (rejected before execution):
- Invalid signature
- Insufficient fee
- Nonce too low (already used)
- Nonce too high (gap too large)
- Invalid wire format

**Execution failures** (fail during execution):
- Insufficient balance
- Contract revert
- Invalid recipient
- Business logic errors

#### 2.D.3 Fee Handling

```python
def execute_transaction(tx, state):
    """
    Transaction execution with fee handling.
    """
    # Step 1: Deduct fee (always, if TX enters block)
    sender_balance = state.get_balance(tx.sender)
    if sender_balance < tx.fee:
        return Error.INSUFFICIENT_FEE

    state.deduct(tx.sender, tx.fee)
    state.increment_nonce(tx.sender)

    # Step 2: Create checkpoint
    checkpoint = state.checkpoint()

    # Step 3: Execute transaction
    try:
        result = execute_payload(tx, state)
        if result.is_error():
            state.rollback(checkpoint)  # Rollback payload effects
            return result               # Fee still charged
        return result
    except Exception as e:
        state.rollback(checkpoint)
        return Error.EXECUTION_FAILED
```

#### 2.D.4 Rollback Semantics

| State Component | Rollback Behavior |
|-----------------|-------------------|
| Sender balance | Fee deducted, transfer amount rolled back |
| Sender nonce | Advanced (NOT rolled back) |
| Recipient balance | Rolled back |
| Contract state | Rolled back |
| Events/logs | Cleared |

**CRITICAL**: Nonce is NEVER rolled back on failure. This prevents replay attacks where a failed transaction could be resubmitted.

#### 2.D.5 Failure Recording

Failed transactions are recorded in blocks with:
```
┌─────────────────┬───────────────────────────────────────────┐
│  txid (32)      │  Transaction ID                           │
├─────────────────┼───────────────────────────────────────────┤
│  error_code (u8)│  Standardized error code                  │
├─────────────────┼───────────────────────────────────────────┤
│  compute_units  │  Computational resources consumed (CU)    │
└─────────────────┴───────────────────────────────────────────┘
```

---

### 2.E Nonce Handling Rules

#### 2.E.1 Overview

The nonce is a strictly monotonically increasing counter per account that:
- Prevents transaction replay
- Orders transactions from the same sender
- Enables transaction replacement

#### 2.E.2 Nonce Validation Rules

| Rule | Description | Error Code |
|------|-------------|------------|
| **Minimum** | nonce >= account.nonce | `NONCE_TOO_LOW` |
| **Maximum** | nonce <= account.nonce + MAX_GAP | `NONCE_TOO_HIGH` |
| **Uniqueness** | No duplicate nonce in mempool | `NONCE_DUPLICATE` |

**MAX_GAP**: Maximum allowed gap between account nonce and transaction nonce (typically 64).

#### 2.E.3 Nonce Processing

**Verification phase** (mempool/block validation):
```python
def verify_nonce(tx, account_state):
    """
    Verify nonce during transaction verification.
    Does NOT modify state.
    """
    expected = account_state.nonce

    if tx.nonce < expected:
        return Error.NONCE_TOO_LOW

    if tx.nonce > expected + MAX_NONCE_GAP:
        return Error.NONCE_TOO_HIGH

    return OK
```

**Execution phase** (block execution):
```python
def apply_nonce(tx, account_state):
    """
    Apply nonce during transaction execution.
    Modifies state.
    """
    # Strict check: nonce must match exactly during execution
    if tx.nonce != account_state.nonce:
        return Error.NONCE_MISMATCH

    account_state.nonce += 1
    return OK
```

#### 2.E.4 Gap Handling

When transactions arrive with gaps:

```
Account nonce: 5
Received: tx(nonce=5), tx(nonce=7), tx(nonce=6), tx(nonce=9)

Mempool state:
  nonce 5: tx(nonce=5)  <- ready
  nonce 6: tx(nonce=6)  <- pending (waiting for 5)
  nonce 7: tx(nonce=7)  <- pending (waiting for 5, 6)
  nonce 9: tx(nonce=9)  <- pending (waiting for 5, 6, 7, 8 missing!)

Execution order (when all arrive):
  tx(nonce=5) -> tx(nonce=6) -> tx(nonce=7)
  tx(nonce=9) blocked until tx(nonce=8) arrives
```

#### 2.E.5 Transaction Replacement

A transaction can be replaced if:
1. Same sender
2. Same nonce
3. Higher fee (by at least MIN_FEE_BUMP = 10%)

```python
def can_replace(new_tx, existing_tx):
    """
    Check if new_tx can replace existing_tx in mempool.
    """
    if new_tx.sender != existing_tx.sender:
        return False
    if new_tx.nonce != existing_tx.nonce:
        return False
    if new_tx.fee < existing_tx.fee * (1 + MIN_FEE_BUMP):
        return False
    return True
```

---

### 2.F State Digest Specification

#### 2.F.1 Purpose

The state digest provides a canonical, deterministic representation of blockchain state for:
- Cross-client state comparison (testing)
- State synchronization verification
- Checkpoint validation

**Note**: State digest is primarily for testing. Production clients may use different internal representations as long as they produce matching digests.

#### 2.F.2 Canonical State Representation

The state is serialized in a deterministic order:

```
┌─────────────────────────────────────────────────────────────┐
│                      State Digest                            │
├─────────────────┬───────────────────────────────────────────┤
│  version (u8)   │  State format version (currently 0x01)    │
├─────────────────┼───────────────────────────────────────────┤
│  block_hash(32) │  Hash of the block this state follows     │
├─────────────────┼───────────────────────────────────────────┤
│  account_count  │  Number of accounts (u32)                 │
├─────────────────┼───────────────────────────────────────────┤
│  accounts       │  Sorted account states (see below)        │
├─────────────────┼───────────────────────────────────────────┤
│  global_state   │  Global protocol state (see below)        │
└─────────────────┴───────────────────────────────────────────┘
```

#### 2.F.3 Account State Encoding

Each account is encoded as:

```
┌─────────────────┬───────────────────────────────────────────┐
│  address (32)   │  Compressed public key                    │
├─────────────────┼───────────────────────────────────────────┤
│  balance (u64)  │  Liquid balance                           │
├─────────────────┼───────────────────────────────────────────┤
│  nonce (u64)    │  Transaction counter                      │
├─────────────────┼───────────────────────────────────────────┤
│  frozen (u64)   │  Frozen (staked) balance                  │
├─────────────────┼───────────────────────────────────────────┤
│  energy (u64)   │  Available energy                         │
├─────────────────┼───────────────────────────────────────────┤
│  flags (u32)    │  Account flags (KYC level, etc.)          │
├─────────────────┼───────────────────────────────────────────┤
│  data_len (u32) │  Length of additional data                │
├─────────────────┼───────────────────────────────────────────┤
│  data           │  Type-specific data (contracts, etc.)     │
└─────────────────┴───────────────────────────────────────────┘
```

**Sorting**: Accounts are sorted by address in lexicographic (byte) order.

#### 2.F.4 Global State Encoding

```
┌─────────────────┬───────────────────────────────────────────┐
│  total_supply   │  Total token supply (u128)                │
├─────────────────┼───────────────────────────────────────────┤
│  total_burned   │  Total tokens burned (u128)               │
├─────────────────┼───────────────────────────────────────────┤
│  total_energy   │  Total network energy (u128)              │
├─────────────────┼───────────────────────────────────────────┤
│  block_height   │  Current block height (u64)               │
├─────────────────┼───────────────────────────────────────────┤
│  timestamp      │  Block timestamp (u64)                    │
└─────────────────┴───────────────────────────────────────────┘
```

#### 2.F.5 Digest Computation

```python
def compute_state_digest(state, block_hash):
    """
    Compute canonical state digest.
    """
    buffer = bytearray()

    # Header
    buffer.append(0x01)  # version
    buffer.extend(block_hash)  # 32 bytes

    # Accounts (sorted)
    accounts = sorted(state.accounts.items(), key=lambda x: x[0])
    buffer.extend(len(accounts).to_bytes(4, 'big'))

    for address, account in accounts:
        buffer.extend(address)  # 32 bytes (compressed public key)
        buffer.extend(account.balance.to_bytes(8, 'big'))
        buffer.extend(account.nonce.to_bytes(8, 'big'))
        buffer.extend(account.frozen.to_bytes(8, 'big'))
        buffer.extend(account.energy.to_bytes(8, 'big'))
        buffer.extend(account.flags.to_bytes(4, 'big'))
        buffer.extend(len(account.data).to_bytes(4, 'big'))
        buffer.extend(account.data)

    # Global state
    buffer.extend(state.total_supply.to_bytes(16, 'big'))
    buffer.extend(state.total_burned.to_bytes(16, 'big'))
    buffer.extend(state.total_energy.to_bytes(16, 'big'))
    buffer.extend(state.block_height.to_bytes(8, 'big'))
    buffer.extend(state.timestamp.to_bytes(8, 'big'))

    # Compute digest
    return sha3_256(bytes(buffer))
```

---

### 2.G Error Codes

#### 2.G.1 Error Code Structure

All error codes are standardized as u16 values:

```
┌─────────────────┬─────────────────────────────────────────┐
│  Category (u8)  │  Specific Error (u8)                    │
│  High byte      │  Low byte                               │
└─────────────────┴─────────────────────────────────────────┘
```

#### 2.G.2 Error Categories

| Category | Range | Description |
|----------|-------|-------------|
| 0x00 | 0x0000-0x00FF | Success / No error |
| 0x01 | 0x0100-0x01FF | Validation errors |
| 0x02 | 0x0200-0x02FF | Authorization errors |
| 0x03 | 0x0300-0x03FF | Resource errors |
| 0x04 | 0x0400-0x04FF | State errors |
| 0x05 | 0x0500-0x05FF | Contract errors |
| 0x06 | 0x0600-0x06FF | Network errors |
| 0xFF | 0xFF00-0xFFFF | Internal/Unknown errors |

#### 2.G.3 Standard Error Codes

**Success (0x00xx)**
| Code | Name | Description |
|------|------|-------------|
| 0x0000 | SUCCESS | Transaction executed successfully |

**Validation Errors (0x01xx)**
| Code | Name | Description |
|------|------|-------------|
| 0x0100 | INVALID_FORMAT | Invalid wire format |
| 0x0101 | INVALID_VERSION | Unsupported protocol version |
| 0x0102 | INVALID_TYPE | Unknown transaction type |
| 0x0103 | INVALID_SIGNATURE | Signature verification failed |
| 0x0104 | INVALID_TIMESTAMP | Timestamp out of acceptable range |
| 0x0105 | INVALID_AMOUNT | Amount is zero or negative |
| 0x0106 | INVALID_ADDRESS | Malformed address |
| 0x0107 | INVALID_PAYLOAD | Payload validation failed |
| 0x0110 | NONCE_TOO_LOW | Nonce already used |
| 0x0111 | NONCE_TOO_HIGH | Nonce gap exceeds maximum |
| 0x0112 | NONCE_DUPLICATE | Duplicate nonce in mempool |

**Authorization Errors (0x02xx)**
| Code | Name | Description |
|------|------|-------------|
| 0x0200 | UNAUTHORIZED | Sender not authorized for operation |
| 0x0201 | KYC_REQUIRED | Operation requires KYC verification |
| 0x0202 | KYC_LEVEL_TOO_LOW | Insufficient KYC level |
| 0x0203 | NOT_OWNER | Sender is not the owner |
| 0x0204 | NOT_COMMITTEE | Sender is not a KYC committee member |
| 0x0205 | NOT_ARBITRATOR | Sender is not an arbitrator |
| 0x0206 | MULTISIG_THRESHOLD | Insufficient multisig approvals |

**Resource Errors (0x03xx)**
| Code | Name | Description |
|------|------|-------------|
| 0x0300 | INSUFFICIENT_BALANCE | Not enough liquid balance |
| 0x0301 | INSUFFICIENT_FEE | Fee too low for transaction |
| 0x0302 | INSUFFICIENT_ENERGY | Not enough energy |
| 0x0303 | INSUFFICIENT_FROZEN | Not enough frozen balance |
| 0x0304 | OVERFLOW | Arithmetic overflow |
| 0x0305 | UNDERFLOW | Arithmetic underflow |

**State Errors (0x04xx)**
| Code | Name | Description |
|------|------|-------------|
| 0x0400 | ACCOUNT_NOT_FOUND | Target account does not exist |
| 0x0401 | ACCOUNT_EXISTS | Account already exists |
| 0x0402 | ESCROW_NOT_FOUND | Escrow does not exist |
| 0x0403 | ESCROW_WRONG_STATE | Escrow in wrong state for operation |
| 0x0404 | DOMAIN_NOT_FOUND | TNS domain does not exist |
| 0x0405 | DOMAIN_EXISTS | TNS domain already registered |
| 0x0406 | DOMAIN_EXPIRED | TNS domain has expired |
| 0x0407 | DELEGATION_NOT_FOUND | Delegation does not exist |
| 0x0408 | DELEGATION_EXISTS | Delegation already exists |
| 0x0409 | SELF_OPERATION | Cannot perform operation on self |

**Contract Errors (0x05xx)**
| Code | Name | Description |
|------|------|-------------|
| 0x0500 | CONTRACT_NOT_FOUND | Contract does not exist |
| 0x0501 | CONTRACT_REVERT | Contract execution reverted |
| 0x0502 | OUT_OF_CU | Contract exceeded compute unit limit |
| 0x0503 | INVALID_OPCODE | Unknown contract opcode |
| 0x0504 | STACK_OVERFLOW | Contract stack overflow |
| 0x0505 | STACK_UNDERFLOW | Contract stack underflow |
| 0x0506 | MEMORY_LIMIT | Contract exceeded memory limit |

**Network Errors (0x06xx)**
| Code | Name | Description |
|------|------|-------------|
| 0x0600 | BLOCK_NOT_FOUND | Referenced block not found |
| 0x0601 | INVALID_PARENT | Invalid parent block reference |
| 0x0602 | INVALID_DIFFICULTY | Difficulty check failed |
| 0x0603 | INVALID_POW | Proof of work invalid |
| 0x0604 | TIMESTAMP_TOO_OLD | Block timestamp too old |
| 0x0605 | TIMESTAMP_TOO_NEW | Block timestamp in future |

**Internal Errors (0xFFxx)**
| Code | Name | Description |
|------|------|-------------|
| 0xFF00 | INTERNAL_ERROR | Unexpected internal error |
| 0xFF01 | NOT_IMPLEMENTED | Feature not implemented |
| 0xFFFF | UNKNOWN | Unknown error |

---

## 3. Extended Test Vector Schema

### 3.1 Current Vector Format

The existing TCK uses simple input/output vectors:

```yaml
algorithm: SHA256
version: 1
test_vectors:
  - name: "empty_string"
    input_hex: ""
    expected_hex: "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
```

### 3.2 Extended State Transition Schema

For multi-client alignment, we extend vectors to include state:

```yaml
# State Transition Vector Schema v1.0
schema_version: 1
domain: "state_transitions"
generator: "TOS Rust v1.0.0"
generated_at: "2026-02-03T10:00:00Z"

test_vectors:
  - name: "transfer_basic"
    description: "Basic transfer between two accounts"

    # Pre-execution state (accounts that matter for this test)
    pre_state:
      accounts:
        - address_hex: "01aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          alias: "alice"  # For readability
          balance: 1000
          nonce: 5
          frozen: 0
          energy: 100
          flags: 0
        - address_hex: "01bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
          alias: "bob"
          balance: 500
          nonce: 3
          frozen: 0
          energy: 50
          flags: 0
      global:
        total_supply: 10000
        block_height: 100

    # Transaction to execute
    transaction:
      type: "Transfer"
      type_id: 1
      sender: "alice"  # Reference by alias
      nonce: 5
      fee: 1
      timestamp: 1700000000000
      payload:
        recipient: "bob"
        amount: 100
      # Optional: full wire format for verification
      wire_hex: "0101aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..."
      signature_hex: "..."

    # Expected result
    expected:
      status: "success"
      error_code: 0x0000
      compute_units: 2000  # Base cost for Transfer

    # Post-execution state
    post_state:
      accounts:
        - address_hex: "01aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          alias: "alice"
          balance: 899  # 1000 - 100 - 1 (amount + fee)
          nonce: 6      # Incremented
          frozen: 0
          energy: 100
          flags: 0
        - address_hex: "01bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
          alias: "bob"
          balance: 600  # 500 + 100
          nonce: 3      # Unchanged
          frozen: 0
          energy: 50
          flags: 0
      global:
        total_supply: 9999  # 10000 - 1 (fee burned)
        block_height: 100

    # State digest for quick comparison
    state_digest_hex: "abc123..."
```

### 3.3 Block Execution Vector Schema

For testing block execution order and multi-transaction scenarios:

```yaml
schema_version: 1
domain: "block_execution"
generator: "TOS Rust v1.0.0"

test_vectors:
  - name: "block_with_conflicts"
    description: "Block containing transactions with ordering dependencies"

    # Initial state before block
    pre_state:
      accounts:
        - alias: "alice"
          address_hex: "01aaa..."
          balance: 1000
          nonce: 0
        - alias: "bob"
          address_hex: "01bbb..."
          balance: 100
          nonce: 0
        - alias: "carol"
          address_hex: "01ccc..."
          balance: 0
          nonce: 0

    # Block to execute
    block:
      height: 101
      parent_hashes:
        - "0000000000000000000000000000000000000000000000000000000000000001"
      timestamp: 1700000001000
      transactions:
        # Order in block (not necessarily execution order)
        - name: "tx1"
          type: "Transfer"
          sender: "alice"
          nonce: 0
          fee: 1
          payload:
            recipient: "bob"
            amount: 500
        - name: "tx2"
          type: "Transfer"
          sender: "alice"
          nonce: 1
          fee: 2
          payload:
            recipient: "carol"
            amount: 400
        - name: "tx3"
          type: "Transfer"
          sender: "bob"
          nonce: 0
          fee: 1
          payload:
            recipient: "carol"
            amount: 200

    # Expected execution order (by transaction name)
    expected_execution_order:
      - "tx2"  # Higher fee from alice
      - "tx1"  # Lower fee from alice (but tx2 requires nonce 1, so tx1 first? No, nonce ordering)
      - "tx3"  # Different sender

    # Actually: nonce ordering within sender
    # alice: tx1 (nonce 0) before tx2 (nonce 1)
    # Correct order considering both fee and nonce:
    expected_execution_order:
      - "tx1"  # alice nonce 0 (must come before nonce 1)
      - "tx2"  # alice nonce 1
      - "tx3"  # bob nonce 0

    # Individual transaction results
    transaction_results:
      - name: "tx1"
        status: "success"
        error_code: 0x0000
      - name: "tx2"
        status: "success"
        error_code: 0x0000
      - name: "tx3"
        status: "failure"
        error_code: 0x0300  # INSUFFICIENT_BALANCE (bob only has 600, needs 201)

    # Final state
    post_state:
      accounts:
        - alias: "alice"
          balance: 96   # 1000 - 500 - 1 - 400 - 2 = 97... let me recalc
          # tx1: -500 -1 fee = 499
          # tx2: -400 -2 fee = 97
          balance: 97
          nonce: 2
        - alias: "bob"
          # tx1: +500
          # tx3: failed, fee still charged: -1
          balance: 599  # 100 + 500 - 1
          nonce: 1      # Incremented despite failure
        - alias: "carol"
          # tx2: +400
          balance: 400
          nonce: 0

    state_digest_hex: "def456..."
```

### 3.4 Failure Scenario Vector Schema

For testing error handling:

```yaml
schema_version: 1
domain: "failure_scenarios"
generator: "TOS Rust v1.0.0"

test_vectors:
  - name: "insufficient_balance"
    description: "Transfer fails due to insufficient balance"

    pre_state:
      accounts:
        - alias: "alice"
          address_hex: "01aaa..."
          balance: 50  # Less than transfer + fee
          nonce: 0
        - alias: "bob"
          address_hex: "01bbb..."
          balance: 0
          nonce: 0

    transaction:
      type: "Transfer"
      sender: "alice"
      nonce: 0
      fee: 1
      payload:
        recipient: "bob"
        amount: 100  # Exceeds balance

    expected:
      status: "failure"
      error_code: 0x0300  # INSUFFICIENT_BALANCE
      error_name: "INSUFFICIENT_BALANCE"
      # Fee still charged if TX entered block
      fee_charged: true
      nonce_advanced: true

    post_state:
      accounts:
        - alias: "alice"
          balance: 49  # 50 - 1 (fee only)
          nonce: 1     # Advanced
        - alias: "bob"
          balance: 0   # Unchanged
          nonce: 0

  - name: "nonce_too_low"
    description: "Transaction rejected due to already-used nonce"

    pre_state:
      accounts:
        - alias: "alice"
          address_hex: "01aaa..."
          balance: 1000
          nonce: 5  # Already at 5

    transaction:
      type: "Transfer"
      sender: "alice"
      nonce: 4  # Less than account nonce
      fee: 1
      payload:
        recipient: "bob"
        amount: 100

    expected:
      status: "rejected"  # Pre-validation failure
      error_code: 0x0110  # NONCE_TOO_LOW
      error_name: "NONCE_TOO_LOW"
      # Not charged because never entered block
      fee_charged: false
      nonce_advanced: false

    post_state:
      # Unchanged
      accounts:
        - alias: "alice"
          balance: 1000
          nonce: 5
```

### 3.5 TCK Directory Structure

The TCK (Technology Compatibility Kit) follows a professional, industry-standard organization:

```
tck/
├── README.md                        # TCK overview and usage guide
│
├── specs/                           # Critical Path Specifications (Layer 1)
│   ├── wire-format.md               # Binary serialization rules
│   ├── hash-algorithms.md           # Hash function assignments
│   ├── blockdag-ordering.md         # DAG execution order algorithm
│   ├── failed-tx-semantics.md       # Failure handling rules
│   ├── nonce-rules.md               # Nonce validation and processing
│   ├── state-digest.md              # Canonical state representation
│   └── error-codes.md               # Standardized error codes
│
├── vectors/                         # Test Vectors (Layer 2)
│   ├── crypto/                      # Cryptographic primitives (existing)
│   │   ├── sha256.yaml
│   │   ├── sha3-256.yaml
│   │   ├── blake3.yaml
│   │   ├── ed25519.yaml
│   │   └── ...
│   ├── wire/                        # Wire format encoding (existing)
│   │   ├── transfer.yaml
│   │   ├── burn.yaml
│   │   ├── energy.yaml
│   │   └── ...
│   ├── state/                       # State transition vectors (new)
│   │   ├── transfer.yaml
│   │   ├── transfer-edge-cases.yaml
│   │   ├── energy-buy.yaml
│   │   ├── energy-delegate.yaml
│   │   ├── escrow-lifecycle.yaml
│   │   └── ...
│   ├── execution/                   # Block execution vectors (new)
│   │   ├── single-tx-block.yaml
│   │   ├── multi-tx-ordering.yaml
│   │   ├── nonce-ordering.yaml
│   │   ├── dag-reorg.yaml
│   │   └── ...
│   └── errors/                      # Error scenario vectors (new)
│       ├── validation-errors.yaml
│       ├── resource-errors.yaml
│       ├── state-errors.yaml
│       ├── contract-errors.yaml
│       └── ...
│
├── generators/                      # Rust Vector Generators
│   ├── crypto/                      # Cryptographic vector generators (existing)
│   │   ├── gen_sha256_vectors.rs
│   │   ├── gen_blake3_vectors.rs
│   │   └── ...
│   ├── wire/                        # Wire format generators (existing)
│   │   ├── gen_transfer_vectors.rs
│   │   ├── gen_burn_vectors.rs
│   │   └── ...
│   ├── state/                       # State transition generators (new)
│   │   ├── gen_transfer_state.rs
│   │   ├── gen_energy_state.rs
│   │   └── ...
│   └── execution/                   # Block execution generators (new)
│       ├── gen_block_ordering.rs
│       └── ...
│
├── conformance/                     # Conformance Testing Infrastructure (Layer 3)
│   ├── README.md                    # Conformance testing guide
│   ├── docker-compose.yml           # Multi-client orchestration
│   ├── Dockerfile.tos-rust          # TOS Rust test image
│   │
│   ├── harness/                     # Test Driver (Python)
│   │   ├── requirements.txt
│   │   ├── __init__.py
│   │   ├── runner.py                # Main test runner
│   │   ├── comparator.py            # Result comparison logic
│   │   ├── reporter.py              # Report generation (HTML/JSON)
│   │   └── config.py                # Configuration management
│   │
│   ├── api/                         # Diff-Test API Specification
│   │   ├── openapi.yaml             # OpenAPI 3.0 schema
│   │   └── README.md                # API usage guide
│   │
│   └── results/                     # Test Results (gitignored)
│       └── .gitkeep
│
└── fuzz/                            # Fuzz Testing Infrastructure
    ├── README.md                    # Fuzzing guide
    ├── corpus/                      # Seed corpus
    │   ├── transactions/            # Valid transaction seeds
    │   └── blocks/                  # Valid block seeds
    ├── targets/                     # Fuzz Targets (Rust)
    │   ├── tx_parse.rs              # Transaction parsing fuzzer
    │   ├── tx_execute.rs            # Transaction execution fuzzer
    │   ├── block_execute.rs         # Block execution fuzzer
    │   └── wire_roundtrip.rs        # Serialization roundtrip fuzzer
    └── scripts/
        ├── run-libfuzzer.sh         # LibFuzzer runner
        ├── run-afl.sh               # AFL++ runner
        └── minimize-corpus.sh       # Corpus minimization
```

#### Directory Naming Rationale

| Directory | Industry Reference | Purpose |
|-----------|-------------------|---------|
| `specs/` | OpenAPI, gRPC | Human-readable specifications |
| `vectors/` | Ethereum, Bitcoin | Machine-readable test cases |
| `generators/` | Standard practice | Code that produces vectors |
| `conformance/` | Kubernetes, CNCF | Multi-client compatibility testing |
| `fuzz/` | Security industry | Randomized testing infrastructure |
| `harness/` | Testing frameworks | Test execution driver |
| `corpus/` | Fuzzing standard | Seed inputs for fuzzers |

---

## 4. Differential Testing Architecture

### 4.1 Overview

Differential testing runs the same inputs through multiple implementations and compares outputs.

```
                          ┌─────────────────┐
                          │   Test Input    │
                          │  (TX or Block)  │
                          └────────┬────────┘
                                   │
              ┌────────────────────┼────────────────────┐
              │                    │                    │
              ▼                    ▼                    ▼
       ┌─────────────┐      ┌─────────────┐     ┌─────────────┐
       │  TOS Rust   │      │  Avatar C   │     │  Future Go  │
       │  Container  │      │  Container  │     │  Container  │
       └──────┬──────┘      └──────┬──────┘     └──────┬──────┘
              │                    │                    │
              ▼                    ▼                    ▼
       ┌─────────────┐      ┌─────────────┐     ┌─────────────┐
       │   Result    │      │   Result    │     │   Result    │
       │ + State     │      │ + State     │     │ + State     │
       └──────┬──────┘      └──────┬──────┘     └──────┬──────┘
              │                    │                    │
              └────────────────────┼────────────────────┘
                                   │
                                   ▼
                          ┌─────────────────┐
                          │   Comparator    │
                          │                 │
                          │ Results match?  │
                          │ States match?   │
                          └─────────────────┘
```

### 4.2 Docker Compose Setup

Located at `tck/conformance/docker-compose.yml`:

```yaml
# tck/conformance/docker-compose.yml
version: '3.8'

services:
  orchestrator:
    build: ./harness
    volumes:
      - ../vectors:/vectors:ro
      - ./results:/results
    depends_on:
      - tos-rust
      - avatar-c
    environment:
      - RUST_ENDPOINT=http://tos-rust:8080
      - C_ENDPOINT=http://avatar-c:8080
      - VECTOR_DIR=/vectors
      - RESULT_DIR=/results

  tos-rust:
    build:
      context: ../../..
      dockerfile: tck/conformance/Dockerfile.tos-rust
    ports:
      - "8081:8080"
    volumes:
      - tos-rust-state:/state
    command: ["--conformance-mode", "--state-dir=/state"]

  avatar-c:
    build:
      context: ../../../../avatar
      dockerfile: Dockerfile.conformance
    ports:
      - "8082:8080"
    volumes:
      - avatar-c-state:/state
    command: ["--conformance-mode", "--state-dir=/state"]

volumes:
  tos-rust-state:
  avatar-c-state:
```

### 4.3 Diff-Test API Specification

Each client exposes a standardized HTTP API for differential testing:

**Endpoints**:

```
POST /state/reset
  Reset state to empty (genesis)
  Response: { "success": true }

POST /state/load
  Load state from JSON
  Body: { "accounts": [...], "global": {...} }
  Response: { "success": true, "state_digest": "abc..." }

POST /tx/execute
  Execute a single transaction
  Body: { "wire_hex": "...", "expected_state_digest": "..." }
  Response: {
    "success": true/false,
    "error_code": 0x0000,
    "state_digest": "def...",
    "compute_units": 2000
  }

POST /block/execute
  Execute a block of transactions
  Body: { "block_hex": "...", "expected_state_digest": "..." }
  Response: {
    "success": true/false,
    "transaction_results": [...],
    "state_digest": "ghi...",
    "execution_order": [txid1, txid2, ...]
  }

GET /state/digest
  Get current state digest
  Response: { "state_digest": "..." }

GET /state/account/{address_hex}
  Get account state
  Response: { "balance": 1000, "nonce": 5, ... }
```

### 4.4 Test Harness Implementation

Located at `tck/conformance/harness/runner.py`:

```python
# tck/conformance/harness/runner.py

import asyncio
import aiohttp
from typing import List, Dict, Any

class DiffTestHarness:
    def __init__(self, endpoints: Dict[str, str]):
        """
        Initialize harness with client endpoints.
        endpoints: {"rust": "http://...", "c": "http://..."}
        """
        self.endpoints = endpoints
        self.session = None

    async def setup(self):
        self.session = aiohttp.ClientSession()

    async def teardown(self):
        await self.session.close()

    async def reset_all(self):
        """Reset all clients to genesis state."""
        tasks = [
            self.session.post(f"{ep}/state/reset")
            for ep in self.endpoints.values()
        ]
        await asyncio.gather(*tasks)

    async def load_state(self, state: Dict[str, Any]):
        """Load identical state into all clients."""
        tasks = [
            self.session.post(f"{ep}/state/load", json=state)
            for ep in self.endpoints.values()
        ]
        responses = await asyncio.gather(*tasks)

        # Verify all state digests match
        digests = [r.json()["state_digest"] for r in responses]
        if len(set(digests)) > 1:
            raise DivergenceError(f"State load divergence: {digests}")

        return digests[0]

    async def execute_tx(self, wire_hex: str) -> Dict[str, Any]:
        """Execute transaction on all clients and compare."""
        tasks = [
            self.session.post(
                f"{ep}/tx/execute",
                json={"wire_hex": wire_hex}
            )
            for name, ep in self.endpoints.items()
        ]
        responses = await asyncio.gather(*tasks)

        results = {
            name: resp.json()
            for name, resp in zip(self.endpoints.keys(), responses)
        }

        # Compare results
        self._compare_results(results)

        return results

    def _compare_results(self, results: Dict[str, Dict[str, Any]]):
        """Compare results from all clients."""
        clients = list(results.keys())
        reference = results[clients[0]]

        for client in clients[1:]:
            other = results[client]

            # Compare error codes
            if reference["error_code"] != other["error_code"]:
                raise DivergenceError(
                    f"Error code mismatch: {clients[0]}={reference['error_code']}, "
                    f"{client}={other['error_code']}"
                )

            # Compare state digests
            if reference["state_digest"] != other["state_digest"]:
                raise DivergenceError(
                    f"State digest mismatch: {clients[0]}={reference['state_digest']}, "
                    f"{client}={other['state_digest']}"
                )

    async def run_vector_suite(self, vectors_path: str):
        """Run all vectors from a YAML file."""
        import yaml

        with open(vectors_path) as f:
            suite = yaml.safe_load(f)

        results = []
        for vector in suite["test_vectors"]:
            await self.reset_all()

            if "pre_state" in vector:
                await self.load_state(vector["pre_state"])

            try:
                result = await self.execute_tx(vector["transaction"]["wire_hex"])
                results.append({
                    "name": vector["name"],
                    "status": "pass",
                    "results": result
                })
            except DivergenceError as e:
                results.append({
                    "name": vector["name"],
                    "status": "fail",
                    "error": str(e)
                })

        return results


class DivergenceError(Exception):
    """Raised when client outputs diverge."""
    pass
```

### 4.5 Fuzzing Integration

**LibFuzzer Integration** (for Rust):

Located at `tck/fuzz/targets/tx_execute.rs`:

```rust
// tck/fuzz/targets/tx_execute.rs

#![no_main]
use libfuzzer_sys::fuzz_target;
use tos_core::transaction::Transaction;
use tos_core::state::State;

fuzz_target!(|data: &[u8]| {
    // Try to parse as transaction
    if let Ok(tx) = Transaction::from_bytes(data) {
        // Execute on clean state
        let mut state = State::genesis();
        let _ = state.execute_transaction(&tx);

        // Output state digest for comparison
        let digest = state.compute_digest();

        // Write to shared location for cross-client comparison
        // (In practice, use IPC or shared memory)
    }
});
```

**AFL++ Integration** (for C):

Located at `avatar/tck/fuzz/tx_harness.c` (in Avatar repository):

```c
// avatar/tck/fuzz/tx_harness.c

#include <at/core/transaction.h>
#include <at/core/state.h>

int main(int argc, char **argv) {
    __AFL_INIT();

    unsigned char *buf = NULL;
    size_t buf_len = 0;

    while (__AFL_LOOP(10000)) {
        buf_len = read(STDIN_FILENO, buf, MAX_TX_SIZE);

        // Try to parse as transaction
        at_transaction_t tx;
        if (at_transaction_parse(&tx, buf, buf_len) == 0) {
            // Execute on clean state
            at_state_t state;
            at_state_genesis(&state);
            at_state_execute_tx(&state, &tx);

            // Output state digest
            uchar digest[32];
            at_state_digest(&state, digest);

            // Write for cross-client comparison
        }
    }

    return 0;
}
```

### 4.6 CI/CD Integration

Located at `.github/workflows/conformance.yml`:

```yaml
# .github/workflows/conformance.yml

name: Conformance Testing

on:
  pull_request:
    branches: [main]
    paths:
      - 'tck/**'
      - 'common/**'
      - 'daemon/**'
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM

jobs:
  vector-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Build containers
        working-directory: tck/conformance
        run: docker-compose build

      - name: Run conformance tests
        working-directory: tck/conformance
        run: |
          docker-compose up -d
          docker-compose exec orchestrator python runner.py --vectors=/vectors
          docker-compose down

      - name: Upload results
        uses: actions/upload-artifact@v3
        with:
          name: conformance-results
          path: tck/conformance/results/

  fuzz-tests:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    steps:
      - uses: actions/checkout@v3

      - name: Run fuzzing (4 hours)
        working-directory: tck/fuzz
        run: |
          ./scripts/run-libfuzzer.sh --timeout 14400

      - name: Check for divergences
        run: |
          python tck/fuzz/scripts/check_results.py

      - name: Upload crash artifacts
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: fuzz-crashes
          path: tck/fuzz/crashes/
```

---

## 5. Implementation Milestones

### Milestone 1: Foundation (Weeks 1-2)

**Deliverables**:
- [x] `MULTI_CLIENT_ALIGNMENT.md` - Methodology document
- [x] `MULTI_CLIENT_ALIGNMENT_SCHEME.md` - This technical specification
- [ ] State transition vector schema finalized
- [ ] First 10 state transition vectors (Transfer, Burn)

**Acceptance Criteria**:
- Documents reviewed by both teams
- Schema can represent all test case types
- Avatar C can parse extended vector format

### Milestone 2: Vector Coverage (Weeks 3-6)

**Deliverables**:
- [ ] State transition vectors for core TX types (0-17)
- [ ] State transition vectors for escrow TX types (24-32)
- [ ] Block execution vectors (10 scenarios)
- [ ] Failure scenario vectors (50+ cases)

**Acceptance Criteria**:
- 100% of TX types have at least 5 vectors
- Avatar C passes all vector tests
- Vector generation is automated

### Milestone 3: Differential Testing (Weeks 7-10)

**Deliverables**:
- [ ] Docker-based test harness
- [ ] Diff-test API implemented in both clients
- [ ] CI/CD integration
- [ ] Initial fuzzing campaign

**Acceptance Criteria**:
- Harness runs in CI on every PR
- No consensus-breaking divergences
- 1000 CPU-hours of fuzzing completed

### Milestone 4: Production Readiness (Weeks 11-14)

**Deliverables**:
- [ ] All critical path specs verified
- [ ] Full vector coverage (90%+)
- [ ] Divergence resolution process documented
- [ ] Maintenance procedures established

**Acceptance Criteria**:
- Both clients pass all tests
- Fuzzing finds no new divergences
- Process for adding new vectors documented

### Milestone 5: Continuous Alignment (Ongoing)

**Deliverables**:
- [ ] New vectors for each protocol change
- [ ] Quarterly fuzzing campaigns
- [ ] Spec updates within 1 week of changes
- [ ] Third-party client onboarding guide

**Acceptance Criteria**:
- No regressions in releases
- New features have vectors before merge
- Third-party clients can use infrastructure

---

## Appendix A: Vector Generator Template

Located at `tck/generators/state/gen_transfer_state.rs`:

```rust
// tck/generators/state/gen_transfer_state.rs

use serde::Serialize;
use std::fs::File;
use std::io::Write;

#[derive(Serialize)]
struct Account {
    address_hex: String,
    alias: String,
    balance: u64,
    nonce: u64,
    frozen: u64,
    energy: u64,
    flags: u32,
}

#[derive(Serialize)]
struct PreState {
    accounts: Vec<Account>,
}

#[derive(Serialize)]
struct TransferPayload {
    recipient: String,
    amount: u64,
}

#[derive(Serialize)]
struct Transaction {
    #[serde(rename = "type")]
    tx_type: String,
    type_id: u8,
    sender: String,
    nonce: u64,
    fee: u64,
    timestamp: u64,
    payload: TransferPayload,
    wire_hex: String,
}

#[derive(Serialize)]
struct Expected {
    status: String,
    error_code: u16,
}

#[derive(Serialize)]
struct TestVector {
    name: String,
    description: String,
    pre_state: PreState,
    transaction: Transaction,
    expected: Expected,
    post_state: PreState,
    state_digest_hex: String,
}

#[derive(Serialize)]
struct VectorFile {
    schema_version: u8,
    domain: String,
    generator: String,
    test_vectors: Vec<TestVector>,
}

fn main() {
    let mut vectors = Vec::new();

    // Vector 1: Basic transfer
    vectors.push(generate_basic_transfer());

    // Vector 2: Transfer with zero amount (should fail)
    vectors.push(generate_zero_amount_transfer());

    // Vector 3: Transfer exceeding balance
    vectors.push(generate_insufficient_balance_transfer());

    // ... more vectors

    let file = VectorFile {
        schema_version: 1,
        domain: "state_transitions".to_string(),
        generator: "TOS Rust v1.0.0".to_string(),
        test_vectors: vectors,
    };

    let yaml = serde_yaml::to_string(&file).expect("Failed to serialize");
    let mut f = File::create("../vectors/state/transfer.yaml").expect("Failed to create file");
    f.write_all(yaml.as_bytes()).expect("Failed to write");
}

fn generate_basic_transfer() -> TestVector {
    // Create accounts
    let alice = create_account("alice", "01aaa...", 1000, 5);
    let bob = create_account("bob", "01bbb...", 500, 3);

    // Create transaction
    let tx = create_transfer_tx("alice", "bob", 100, 1, 5);

    // Execute to get post-state and digest
    let mut state = State::from_accounts(vec![alice.clone(), bob.clone()]);
    state.execute(&tx);

    TestVector {
        name: "transfer_basic".to_string(),
        description: "Basic transfer between two accounts".to_string(),
        pre_state: PreState { accounts: vec![alice, bob] },
        transaction: tx,
        expected: Expected {
            status: "success".to_string(),
            error_code: 0x0000,
        },
        post_state: state.to_pre_state(),
        state_digest_hex: hex::encode(state.compute_digest()),
    }
}
```

---

## Appendix B: Vector Consumer Template

Located at `avatar/src/tck/test_state_yaml.c` (in Avatar repository):

```c
// avatar/src/tck/test_state_yaml.c

#include <at/core/infra/runtime/at_yaml.h>
#include <at/core/state.h>
#include <at/core/transaction.h>

static _Thread_local at_yaml_doc_t doc;

static int
load_pre_state(at_state_t *state, at_yaml_obj_t const *pre_state) {
    at_yaml_array_t const *accounts = at_yaml_obj_get_array(pre_state, "accounts");
    if (!accounts) return -1;

    for (int i = 0; i < accounts->item_count; i++) {
        at_yaml_obj_t const *acc = &accounts->items[i];

        char const *addr_hex = at_yaml_obj_get_string(acc, "address_hex");
        long balance = at_yaml_obj_get_int(acc, "balance", 0);
        long nonce = at_yaml_obj_get_int(acc, "nonce", 0);

        uchar addr[21];
        at_yaml_hex_to_bytes(addr, 21, addr_hex);

        at_state_set_account(state, addr, balance, nonce, 0, 0, 0);
    }

    return 0;
}

static int
test_vector(at_yaml_obj_t const *vec) {
    char const *name = at_yaml_obj_get_string(vec, "name");
    printf("Testing: %s\n", name);

    // Load pre-state
    at_state_t state;
    at_state_init(&state);
    at_yaml_obj_t const *pre_state = at_yaml_obj_get_obj(vec, "pre_state");
    if (load_pre_state(&state, pre_state) != 0) {
        printf("FAIL: %s - could not load pre_state\n", name);
        return 1;
    }

    // Parse and execute transaction
    at_yaml_obj_t const *tx_obj = at_yaml_obj_get_obj(vec, "transaction");
    char const *wire_hex = at_yaml_obj_get_string(tx_obj, "wire_hex");

    uchar wire[4096];
    int wire_len = at_yaml_hex_to_bytes(wire, sizeof(wire), wire_hex);

    at_transaction_t tx;
    if (at_transaction_parse(&tx, wire, wire_len) != 0) {
        printf("FAIL: %s - could not parse transaction\n", name);
        return 1;
    }

    int result = at_state_execute_tx(&state, &tx);

    // Check expected result
    at_yaml_obj_t const *expected = at_yaml_obj_get_obj(vec, "expected");
    long expected_code = at_yaml_obj_get_int(expected, "error_code", 0);

    if (result != (int)expected_code) {
        printf("FAIL: %s - error code mismatch (expected %ld, got %d)\n",
               name, expected_code, result);
        return 1;
    }

    // Check state digest
    char const *expected_digest = at_yaml_obj_get_string(vec, "state_digest_hex");
    uchar digest[32];
    at_state_digest(&state, digest);

    uchar expected_digest_bytes[32];
    at_yaml_hex_to_bytes(expected_digest_bytes, 32, expected_digest);

    if (at_memcmp(digest, expected_digest_bytes, 32) != 0) {
        printf("FAIL: %s - state digest mismatch\n", name);
        return 1;
    }

    printf("PASS: %s\n", name);
    return 0;
}

int main(int argc, char **argv) {
    char const *yaml_path = "tck/vectors/state/transfer.yaml";
    if (argc > 1) yaml_path = argv[1];

    if (at_yaml_parse_file(&doc, yaml_path) != 0) {
        printf("FAIL: Could not parse YAML file: %s\n", yaml_path);
        return 1;
    }

    at_yaml_array_t const *vectors = at_yaml_get_array(&doc, "test_vectors");
    if (!vectors) {
        printf("FAIL: test_vectors not found\n");
        return 1;
    }

    int fail = 0;
    for (int i = 0; i < vectors->item_count; i++) {
        fail += test_vector(&vectors->items[i]);
    }

    printf("\n%d tests, %d failed\n", vectors->item_count, fail);
    return fail;
}
```

---

*Document Version: 1.1*
*Last Updated: 2026-02-04*
*Status: Draft*

**Revision History**:
- v1.1 (2026-02-04): Fixed endianness (Big-endian), address format (32-byte CompressedPublicKey with Bech32), DAG ordering (cumulative-difficulty, not GHOSTDAG), terminology (compute_units, not gas)
