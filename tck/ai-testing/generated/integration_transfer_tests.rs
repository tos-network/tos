//! AI-Generated Transfer Integration Tests
//!
//! Generated by Claude Code for TOS-TCK
//! Tests for transfer operations across the system

use tos_tck::test_utils::*;

// =============================================================================
// Basic Transfer Tests
// =============================================================================

#[test]
fn test_simple_transfer() {
    // Basic TOS transfer between accounts
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000);
    let receiver = env.create_account();

    let result = env.transfer(&sender, &receiver, 500);

    assert!(result.is_ok());
    assert_eq!(env.get_balance(&sender), 500);
    assert_eq!(env.get_balance(&receiver), 500);
}

#[test]
fn test_transfer_exact_balance() {
    // Transfer entire balance
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000);
    let receiver = env.create_account();

    // Need to account for gas
    let gas_cost = 21000 * env.gas_price();
    let transfer_amount = 1000 - gas_cost;

    let result = env.transfer(&sender, &receiver, transfer_amount);

    assert!(result.is_ok());
    assert_eq!(env.get_balance(&sender), 0);
}

#[test]
fn test_transfer_to_self() {
    // Transfer to self should work
    let mut env = TestEnv::new();
    let account = env.create_account_with_balance(1000);

    let result = env.transfer(&account, &account, 500);

    assert!(result.is_ok());
    // Balance should be same minus gas
}

#[test]
fn test_transfer_zero_value() {
    // Zero value transfer should work
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000);
    let receiver = env.create_account();

    let result = env.transfer(&sender, &receiver, 0);

    assert!(result.is_ok());
    assert_eq!(env.get_balance(&receiver), 0);
}

#[test]
fn test_transfer_insufficient_balance() {
    // Transfer more than balance should fail
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(100);
    let receiver = env.create_account();

    let result = env.transfer(&sender, &receiver, 1000);

    assert!(result.is_err());
}

#[test]
fn test_transfer_updates_nonce() {
    // Transfer should increment sender nonce
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000);
    let receiver = env.create_account();

    let nonce_before = env.get_nonce(&sender);
    env.transfer(&sender, &receiver, 100);
    let nonce_after = env.get_nonce(&sender);

    assert_eq!(nonce_after, nonce_before + 1);
}

// =============================================================================
// Contract Transfer Tests
// =============================================================================

#[test]
fn test_contract_receive_transfer() {
    // Contract receiving transfer via receive()
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000);
    let contract = env.deploy_contract("receivable_contract");

    let result = env.transfer(&sender, &contract, 500);

    assert!(result.is_ok());
    assert_eq!(env.get_balance(&contract), 500);
}

#[test]
fn test_contract_without_receive() {
    // Contract without receive/fallback rejects transfer
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000);
    let contract = env.deploy_contract("no_receive_contract");

    let result = env.transfer(&sender, &contract, 500);

    assert!(result.is_err(), "Contract without receive should reject");
}

#[test]
fn test_contract_fallback_called() {
    // Fallback called with data
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000);
    let contract = env.deploy_contract("fallback_contract");

    let result = env.transfer_with_data(&sender, &contract, 500, vec![0x01, 0x02]);

    assert!(result.is_ok());
    assert!(env.fallback_called(&contract));
}

#[test]
fn test_contract_transfer_out() {
    // Contract can transfer funds out
    let mut env = TestEnv::new();
    let contract = env.deploy_contract_with_balance("transfer_out_contract", 1000);
    let receiver = env.create_account();

    let result = env.call_contract_transfer(&contract, &receiver, 500);

    assert!(result.is_ok());
    assert_eq!(env.get_balance(&receiver), 500);
}

// =============================================================================
// Multi-Transfer Tests
// =============================================================================

#[test]
fn test_batch_transfer() {
    // Batch transfer to multiple recipients
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(10000);
    let receivers: Vec<_> = (0..5).map(|_| env.create_account()).collect();

    for receiver in &receivers {
        env.transfer(&sender, receiver, 100);
    }

    for receiver in &receivers {
        assert_eq!(env.get_balance(receiver), 100);
    }
}

#[test]
fn test_sequential_transfers_same_sender() {
    // Multiple transfers from same sender
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000);
    let receiver = env.create_account();

    env.transfer(&sender, &receiver, 100);
    env.transfer(&sender, &receiver, 100);
    env.transfer(&sender, &receiver, 100);

    assert_eq!(env.get_balance(&receiver), 300);
}

#[test]
fn test_chain_of_transfers() {
    // Transfer chain: A -> B -> C
    let mut env = TestEnv::new();
    let a = env.create_account_with_balance(1000);
    let b = env.create_account();
    let c = env.create_account();

    env.transfer(&a, &b, 500);
    env.transfer(&b, &c, 300);

    assert_eq!(env.get_balance(&c), 300);
}

// =============================================================================
// Gas and Fee Tests
// =============================================================================

#[test]
fn test_transfer_gas_cost() {
    // Standard transfer costs 21000 gas
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000000);
    let receiver = env.create_account();

    let result = env.transfer(&sender, &receiver, 100);

    assert_eq!(result.gas_used, 21000);
}

#[test]
fn test_transfer_new_account_gas() {
    // Transfer to new account may cost more
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000000);
    let new_address = Address::from([0x42u8; 20]);

    let result = env.transfer(&sender, &new_address, 100);

    // May include account creation cost
    assert!(result.gas_used >= 21000);
}

#[test]
fn test_transfer_insufficient_gas() {
    // Transfer with insufficient gas fails
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000);
    let receiver = env.create_account();

    let result = env.transfer_with_gas(&sender, &receiver, 100, 20000);

    assert!(result.is_err(), "Should fail with insufficient gas");
}

#[test]
fn test_transfer_gas_refund() {
    // Unused gas is refunded
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(1000000);
    let receiver = env.create_account();

    let balance_before = env.get_balance(&sender);
    let result = env.transfer_with_gas(&sender, &receiver, 100, 100000);
    let balance_after = env.get_balance(&sender);

    // Should only be charged for 21000 gas
    let expected_cost = 100 + (21000 * env.gas_price());
    assert_eq!(balance_before - balance_after, expected_cost);
}

// =============================================================================
// ERC20 Transfer Tests
// =============================================================================

#[test]
fn test_erc20_transfer() {
    // Standard ERC20 transfer
    let mut env = TestEnv::new();
    let token = env.deploy_erc20("TestToken", "TTK", 1000000);
    let sender = env.get_token_owner(&token);
    let receiver = env.create_account();

    let result = env.erc20_transfer(&token, &sender, &receiver, 1000);

    assert!(result.is_ok());
    assert_eq!(env.erc20_balance(&token, &receiver), 1000);
}

#[test]
fn test_erc20_transfer_from() {
    // ERC20 transferFrom with approval
    let mut env = TestEnv::new();
    let token = env.deploy_erc20("TestToken", "TTK", 1000000);
    let owner = env.get_token_owner(&token);
    let spender = env.create_account();
    let receiver = env.create_account();

    env.erc20_approve(&token, &owner, &spender, 500);
    let result = env.erc20_transfer_from(&token, &spender, &owner, &receiver, 300);

    assert!(result.is_ok());
    assert_eq!(env.erc20_balance(&token, &receiver), 300);
    assert_eq!(env.erc20_allowance(&token, &owner, &spender), 200);
}

#[test]
fn test_erc20_transfer_exceeds_balance() {
    // ERC20 transfer exceeding balance fails
    let mut env = TestEnv::new();
    let token = env.deploy_erc20("TestToken", "TTK", 1000);
    let owner = env.get_token_owner(&token);
    let receiver = env.create_account();

    let result = env.erc20_transfer(&token, &owner, &receiver, 2000);

    assert!(result.is_err());
}

#[test]
fn test_erc20_transfer_exceeds_allowance() {
    // ERC20 transferFrom exceeding allowance fails
    let mut env = TestEnv::new();
    let token = env.deploy_erc20("TestToken", "TTK", 1000000);
    let owner = env.get_token_owner(&token);
    let spender = env.create_account();
    let receiver = env.create_account();

    env.erc20_approve(&token, &owner, &spender, 100);
    let result = env.erc20_transfer_from(&token, &spender, &owner, &receiver, 500);

    assert!(result.is_err());
}

// =============================================================================
// Cross-Contract Transfer Tests
// =============================================================================

#[test]
fn test_contract_to_contract_transfer() {
    // Contract A transfers to Contract B
    let mut env = TestEnv::new();
    let contract_a = env.deploy_contract_with_balance("transfer_contract", 1000);
    let contract_b = env.deploy_contract("receivable_contract");

    let result = env.call_contract_transfer(&contract_a, &contract_b, 500);

    assert!(result.is_ok());
    assert_eq!(env.get_balance(&contract_b), 500);
}

#[test]
fn test_transfer_with_callback() {
    // Transfer triggers callback in receiver
    let mut env = TestEnv::new();
    let sender = env.deploy_contract_with_balance("sender_contract", 1000);
    let receiver = env.deploy_contract("callback_receiver");

    env.call_transfer_with_callback(&sender, &receiver, 500);

    assert!(env.callback_executed(&receiver));
}

#[test]
fn test_transfer_reverts_on_callback_failure() {
    // Transfer reverts if callback fails
    let mut env = TestEnv::new();
    let sender = env.deploy_contract_with_balance("sender_contract", 1000);
    let receiver = env.deploy_contract("failing_receiver");

    let result = env.call_transfer_with_callback(&sender, &receiver, 500);

    assert!(result.is_err());
    assert_eq!(env.get_balance(&sender), 1000, "Balance should be unchanged");
}
