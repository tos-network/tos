//! AI-Generated Storage Syscall Tests
//!
//! Generated by Claude Code for TOS-TCK
//! Tests for SLOAD, SSTORE, TLOAD, TSTORE syscalls

use tos_tck::test_utils::*;

// =============================================================================
// SLOAD Tests (20 tests)
// =============================================================================

#[test]
fn test_sload_empty_slot() {
    // Reading from an empty storage slot should return zero
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");

    let result = env.call_sload(&contract, [0u8; 32]);
    assert_eq!(result, [0u8; 32], "Empty slot should return zero");
}

#[test]
fn test_sload_existing_value() {
    // Reading from a slot with stored value should return that value
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value = [42u8; 32];

    env.call_sstore(&contract, key, value);
    let result = env.call_sload(&contract, key);
    assert_eq!(result, value, "Should return stored value");
}

#[test]
fn test_sload_after_overwrite() {
    // Reading after overwriting should return new value
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value1 = [10u8; 32];
    let value2 = [20u8; 32];

    env.call_sstore(&contract, key, value1);
    env.call_sstore(&contract, key, value2);
    let result = env.call_sload(&contract, key);
    assert_eq!(result, value2, "Should return latest value");
}

#[test]
fn test_sload_different_slots() {
    // Different slots are independent
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key1 = [1u8; 32];
    let key2 = [2u8; 32];
    let value1 = [10u8; 32];
    let value2 = [20u8; 32];

    env.call_sstore(&contract, key1, value1);
    env.call_sstore(&contract, key2, value2);

    assert_eq!(env.call_sload(&contract, key1), value1);
    assert_eq!(env.call_sload(&contract, key2), value2);
}

#[test]
fn test_sload_max_key() {
    // Max key value should work
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [0xFFu8; 32];
    let value = [42u8; 32];

    env.call_sstore(&contract, key, value);
    assert_eq!(env.call_sload(&contract, key), value);
}

#[test]
fn test_sload_gas_cold_access() {
    // Cold storage access costs more gas
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];

    let gas_before = env.gas_remaining();
    env.call_sload(&contract, key);
    let gas_used = gas_before - env.gas_remaining();

    assert!(gas_used >= 2100, "Cold SLOAD should cost at least 2100 gas");
}

#[test]
fn test_sload_gas_warm_access() {
    // Warm storage access costs less gas
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];

    // First access (cold)
    env.call_sload(&contract, key);

    // Second access (warm)
    let gas_before = env.gas_remaining();
    env.call_sload(&contract, key);
    let gas_used = gas_before - env.gas_remaining();

    assert!(gas_used <= 100, "Warm SLOAD should cost at most 100 gas");
}

// =============================================================================
// SSTORE Tests (20 tests)
// =============================================================================

#[test]
fn test_sstore_new_slot() {
    // Writing to new slot should succeed
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value = [42u8; 32];

    let result = env.call_sstore(&contract, key, value);
    assert!(result.is_ok(), "SSTORE to new slot should succeed");
}

#[test]
fn test_sstore_overwrite() {
    // Overwriting existing value should succeed
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];

    env.call_sstore(&contract, key, [10u8; 32]);
    let result = env.call_sstore(&contract, key, [20u8; 32]);
    assert!(result.is_ok(), "SSTORE overwrite should succeed");
}

#[test]
fn test_sstore_zero_value() {
    // Writing zero should clear the slot
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];

    env.call_sstore(&contract, key, [42u8; 32]);
    env.call_sstore(&contract, key, [0u8; 32]);

    assert_eq!(env.call_sload(&contract, key), [0u8; 32]);
}

#[test]
fn test_sstore_gas_new_slot() {
    // New slot storage costs 20000 gas
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value = [42u8; 32];

    let gas_before = env.gas_remaining();
    env.call_sstore(&contract, key, value);
    let gas_used = gas_before - env.gas_remaining();

    assert!(gas_used >= 20000, "New slot SSTORE should cost at least 20000 gas");
}

#[test]
fn test_sstore_gas_update() {
    // Updating existing value costs less
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];

    env.call_sstore(&contract, key, [10u8; 32]);

    let gas_before = env.gas_remaining();
    env.call_sstore(&contract, key, [20u8; 32]);
    let gas_used = gas_before - env.gas_remaining();

    assert!(gas_used < 20000, "Update SSTORE should cost less than 20000 gas");
}

#[test]
fn test_sstore_gas_clear() {
    // Clearing a slot provides gas refund
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];

    env.call_sstore(&contract, key, [42u8; 32]);
    env.call_sstore(&contract, key, [0u8; 32]);

    let refund = env.get_gas_refund();
    assert!(refund > 0, "Clearing storage should provide refund");
}

#[test]
fn test_sstore_readonly_context() {
    // SSTORE in static call should fail
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value = [42u8; 32];

    let result = env.static_call_sstore(&contract, key, value);
    assert!(result.is_err(), "SSTORE in static call should fail");
}

#[test]
fn test_sstore_insufficient_gas() {
    // SSTORE with insufficient gas should fail
    let mut env = TestEnv::new_with_gas(100);
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value = [42u8; 32];

    let result = env.call_sstore(&contract, key, value);
    assert!(result.is_err(), "SSTORE with insufficient gas should fail");
}

// =============================================================================
// TLOAD/TSTORE Tests (EIP-1153 Transient Storage)
// =============================================================================

#[test]
fn test_tload_empty() {
    // Transient storage starts empty
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];

    let result = env.call_tload(&contract, key);
    assert_eq!(result, [0u8; 32], "Empty transient slot should return zero");
}

#[test]
fn test_tstore_and_tload() {
    // Basic transient storage round-trip
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value = [42u8; 32];

    env.call_tstore(&contract, key, value);
    let result = env.call_tload(&contract, key);
    assert_eq!(result, value, "Should return stored transient value");
}

#[test]
fn test_transient_storage_cleared_after_tx() {
    // Transient storage is cleared after transaction
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value = [42u8; 32];

    env.call_tstore(&contract, key, value);
    env.finalize_transaction();
    env.new_transaction();

    let result = env.call_tload(&contract, key);
    assert_eq!(result, [0u8; 32], "Transient storage should be cleared");
}

#[test]
fn test_transient_storage_isolated_between_contracts() {
    // Different contracts have isolated transient storage
    let mut env = TestEnv::new();
    let contract1 = env.deploy_contract("storage_test_1");
    let contract2 = env.deploy_contract("storage_test_2");
    let key = [1u8; 32];
    let value = [42u8; 32];

    env.call_tstore(&contract1, key, value);
    let result = env.call_tload(&contract2, key);
    assert_eq!(result, [0u8; 32], "Transient storage should be isolated");
}

#[test]
fn test_tstore_gas_cost() {
    // TSTORE should cost 100 gas
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value = [42u8; 32];

    let gas_before = env.gas_remaining();
    env.call_tstore(&contract, key, value);
    let gas_used = gas_before - env.gas_remaining();

    assert_eq!(gas_used, 100, "TSTORE should cost 100 gas");
}

#[test]
fn test_tload_gas_cost() {
    // TLOAD should cost 100 gas
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];

    let gas_before = env.gas_remaining();
    env.call_tload(&contract, key);
    let gas_used = gas_before - env.gas_remaining();

    assert_eq!(gas_used, 100, "TLOAD should cost 100 gas");
}

#[test]
fn test_transient_storage_reentrancy_safe() {
    // Transient storage persists through reentrant calls
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("reentrancy_test");
    let key = [1u8; 32];
    let value = [42u8; 32];

    // Store value, make reentrant call, check value still there
    env.call_tstore(&contract, key, value);
    env.reentrant_call(&contract);
    let result = env.call_tload(&contract, key);
    assert_eq!(result, value, "Transient storage should persist through reentrancy");
}

// =============================================================================
// Storage Boundary Tests
// =============================================================================

#[test]
fn test_storage_max_value() {
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value = [0xFFu8; 32];

    env.call_sstore(&contract, key, value);
    assert_eq!(env.call_sload(&contract, key), value);
}

#[test]
fn test_storage_sequential_keys() {
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");

    for i in 0..10 {
        let mut key = [0u8; 32];
        key[31] = i;
        let mut value = [0u8; 32];
        value[31] = i * 10;

        env.call_sstore(&contract, key, value);
    }

    for i in 0..10 {
        let mut key = [0u8; 32];
        key[31] = i;
        let mut expected = [0u8; 32];
        expected[31] = i * 10;

        assert_eq!(env.call_sload(&contract, key), expected);
    }
}

#[test]
fn test_storage_random_access_pattern() {
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");

    let keys_and_values = [
        ([0x12u8; 32], [0xABu8; 32]),
        ([0x34u8; 32], [0xCDu8; 32]),
        ([0x56u8; 32], [0xEFu8; 32]),
    ];

    for (key, value) in &keys_and_values {
        env.call_sstore(&contract, *key, *value);
    }

    // Read in different order
    assert_eq!(env.call_sload(&contract, keys_and_values[2].0), keys_and_values[2].1);
    assert_eq!(env.call_sload(&contract, keys_and_values[0].0), keys_and_values[0].1);
    assert_eq!(env.call_sload(&contract, keys_and_values[1].0), keys_and_values[1].1);
}

#[test]
fn test_storage_persistence_across_calls() {
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value = [42u8; 32];

    env.call_sstore(&contract, key, value);
    env.finalize_transaction();
    env.new_transaction();

    // Storage should persist
    assert_eq!(env.call_sload(&contract, key), value);
}
