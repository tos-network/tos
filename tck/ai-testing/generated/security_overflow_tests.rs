//! AI-Generated Overflow Security Tests
//!
//! Generated by Claude Code for TOS-TCK
//! Tests for arithmetic overflow/underflow protection

use tos_tck::test_utils::*;

// =============================================================================
// Balance Overflow Tests
// =============================================================================

#[test]
fn test_balance_overflow_prevented() {
    // Adding to max balance should not overflow
    let mut env = TestEnv::new();
    let account = env.create_account_with_balance(u64::MAX);

    let result = env.transfer_to(&account, 1);
    assert!(result.is_err(), "Balance overflow should be prevented");
}

#[test]
fn test_balance_underflow_prevented() {
    // Subtracting more than balance should fail
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(100);
    let receiver = env.create_account();

    let result = env.transfer(&sender, &receiver, 101);
    assert!(result.is_err(), "Balance underflow should be prevented");
}

#[test]
fn test_balance_at_max() {
    // Max balance should be usable
    let mut env = TestEnv::new();
    let account = env.create_account_with_balance(u64::MAX);

    let balance = env.get_balance(&account);
    assert_eq!(balance, u64::MAX);
}

#[test]
fn test_transfer_max_value() {
    // Transfer of max value should work if balance sufficient
    let mut env = TestEnv::new();
    let sender = env.create_account_with_balance(u64::MAX);
    let receiver = env.create_account();

    let result = env.transfer(&sender, &receiver, u64::MAX);
    assert!(result.is_ok());
    assert_eq!(env.get_balance(&receiver), u64::MAX);
}

// =============================================================================
// Nonce Overflow Tests
// =============================================================================

#[test]
fn test_nonce_overflow_prevented() {
    // Nonce at max should prevent further transactions
    let mut env = TestEnv::new();
    let account = env.create_account();
    env.set_nonce(&account, u64::MAX);

    let result = env.send_transaction(&account);
    assert!(result.is_err(), "Nonce overflow should be prevented");
}

#[test]
fn test_nonce_near_max() {
    // Nonce near max should still work
    let mut env = TestEnv::new();
    let account = env.create_account_with_balance(1000000);
    env.set_nonce(&account, u64::MAX - 1);

    let result = env.send_transaction(&account);
    assert!(result.is_ok());
    assert_eq!(env.get_nonce(&account), u64::MAX);
}

// =============================================================================
// Gas Calculation Overflow Tests
// =============================================================================

#[test]
fn test_gas_cost_overflow_prevented() {
    // Gas cost calculation should not overflow
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("gas_test");

    // Try to allocate huge memory (would overflow gas calculation)
    let result = env.call_with_large_memory(&contract, u64::MAX);
    assert!(result.is_err(), "Gas calculation overflow should be prevented");
}

#[test]
fn test_gas_refund_overflow_prevented() {
    // Gas refund should not overflow
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");

    // Clear many storage slots
    for i in 0..1000 {
        let key = [i as u8; 32];
        env.call_sstore(&contract, key, [0u8; 32]);
    }

    let refund = env.get_gas_refund();
    assert!(refund <= env.gas_limit() / 5, "Refund should be capped");
}

#[test]
fn test_gas_limit_max() {
    // Max gas limit should work
    let mut env = TestEnv::new_with_gas(u64::MAX);
    let contract = env.deploy_contract("simple_contract");

    let result = env.call(&contract, vec![]);
    assert!(result.is_ok());
}

// =============================================================================
// Storage Value Overflow Tests
// =============================================================================

#[test]
fn test_storage_max_value() {
    // Max storage value should work
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [1u8; 32];
    let value = [0xFFu8; 32];

    env.call_sstore(&contract, key, value);
    assert_eq!(env.call_sload(&contract, key), value);
}

#[test]
fn test_storage_key_max() {
    // Max storage key should work
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");
    let key = [0xFFu8; 32];
    let value = [0x42u8; 32];

    env.call_sstore(&contract, key, value);
    assert_eq!(env.call_sload(&contract, key), value);
}

// =============================================================================
// EVM Arithmetic Overflow Tests
// =============================================================================

#[test]
fn test_add_overflow_wraps() {
    // EVM ADD wraps on overflow (mod 2^256)
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("arithmetic_test");

    let max = [0xFFu8; 32];
    let one = {
        let mut arr = [0u8; 32];
        arr[31] = 1;
        arr
    };

    let result = env.call_add(&contract, max, one);
    assert_eq!(result, [0u8; 32], "ADD should wrap to 0");
}

#[test]
fn test_sub_underflow_wraps() {
    // EVM SUB wraps on underflow (mod 2^256)
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("arithmetic_test");

    let zero = [0u8; 32];
    let one = {
        let mut arr = [0u8; 32];
        arr[31] = 1;
        arr
    };

    let result = env.call_sub(&contract, zero, one);
    assert_eq!(result, [0xFFu8; 32], "SUB should wrap to max");
}

#[test]
fn test_mul_overflow_wraps() {
    // EVM MUL wraps on overflow (mod 2^256)
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("arithmetic_test");

    let large = {
        let mut arr = [0u8; 32];
        arr[0..16].copy_from_slice(&[0xFFu8; 16]);
        arr
    };

    let result = env.call_mul(&contract, large, large);
    // Result should be truncated to 256 bits
    assert!(result.len() == 32);
}

#[test]
fn test_exp_overflow_wraps() {
    // EVM EXP wraps on overflow
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("arithmetic_test");

    let base = {
        let mut arr = [0u8; 32];
        arr[31] = 2;
        arr
    };
    let exp = {
        let mut arr = [0u8; 32];
        arr[30] = 1; // 256
        arr
    };

    let result = env.call_exp(&contract, base, exp);
    // 2^256 mod 2^256 = 0
    assert_eq!(result, [0u8; 32]);
}

// =============================================================================
// Signed Arithmetic Tests
// =============================================================================

#[test]
fn test_sdiv_min_negative() {
    // SDIV of MIN_INT256 / -1 should not overflow
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("arithmetic_test");

    // MIN_INT256 = -2^255
    let min_int = {
        let mut arr = [0u8; 32];
        arr[0] = 0x80; // Sign bit
        arr
    };
    let neg_one = [0xFFu8; 32];

    let result = env.call_sdiv(&contract, min_int, neg_one);
    // Result is MIN_INT256 (overflow case)
    assert_eq!(result, min_int);
}

#[test]
fn test_smod_min_negative() {
    // SMOD with MIN_INT256 should work
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("arithmetic_test");

    let min_int = {
        let mut arr = [0u8; 32];
        arr[0] = 0x80;
        arr
    };
    let neg_one = [0xFFu8; 32];

    let result = env.call_smod(&contract, min_int, neg_one);
    assert_eq!(result, [0u8; 32], "MIN_INT % -1 should be 0");
}

// =============================================================================
// Shift Overflow Tests
// =============================================================================

#[test]
fn test_shl_large_shift() {
    // SHL by >= 256 should return 0
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("arithmetic_test");

    let value = [0xFFu8; 32];
    let shift = {
        let mut arr = [0u8; 32];
        arr[30] = 1; // 256
        arr
    };

    let result = env.call_shl(&contract, value, shift);
    assert_eq!(result, [0u8; 32], "SHL by 256+ should return 0");
}

#[test]
fn test_shr_large_shift() {
    // SHR by >= 256 should return 0
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("arithmetic_test");

    let value = [0xFFu8; 32];
    let shift = {
        let mut arr = [0u8; 32];
        arr[30] = 1; // 256
        arr
    };

    let result = env.call_shr(&contract, value, shift);
    assert_eq!(result, [0u8; 32], "SHR by 256+ should return 0");
}

#[test]
fn test_sar_large_shift() {
    // SAR by >= 256 should return all 0s or all 1s
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("arithmetic_test");

    let negative = [0xFFu8; 32]; // -1 in two's complement
    let shift = {
        let mut arr = [0u8; 32];
        arr[30] = 1; // 256
        arr
    };

    let result = env.call_sar(&contract, negative, shift);
    assert_eq!(result, [0xFFu8; 32], "SAR negative by 256+ should return all 1s");
}

// =============================================================================
// Memory Expansion Overflow Tests
// =============================================================================

#[test]
fn test_memory_expansion_overflow() {
    // Memory expansion should not overflow
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("memory_test");

    // Try to expand memory to huge size
    let result = env.call_mstore(&contract, u64::MAX - 32, [0u8; 32]);
    assert!(result.is_err(), "Huge memory expansion should fail");
}

#[test]
fn test_calldatacopy_overflow() {
    // CALLDATACOPY size should not overflow
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("calldata_test");

    let result = env.call_calldatacopy_sized(&contract, 0, 0, u64::MAX);
    assert!(result.is_err(), "Huge calldatacopy should fail");
}

#[test]
fn test_returndatacopy_overflow() {
    // RETURNDATACOPY should handle size overflow
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("returndata_test");

    let result = env.call_returndatacopy_sized(&contract, 0, 0, u64::MAX);
    assert!(result.is_err(), "Huge returndatacopy should fail");
}
