//! AI-Generated Consensus Tests
//!
//! Generated by Claude Code for TOS-TCK
//! Tests for consensus mechanisms

use tos_tck::test_utils::*;

// =============================================================================
// Block Validation Tests
// =============================================================================

#[test]
fn test_block_valid_structure() {
    // Valid block should pass validation
    let mut node = TestNode::new();
    let block = node.create_valid_block();

    let result = node.validate_block(&block);
    assert!(result.is_ok(), "Valid block should pass validation");
}

#[test]
fn test_block_invalid_parent_hash() {
    // Block with wrong parent hash should fail
    let mut node = TestNode::new();
    let mut block = node.create_valid_block();
    block.header.parent_hash = [0xFFu8; 32];

    let result = node.validate_block(&block);
    assert!(result.is_err(), "Wrong parent hash should fail");
    assert_eq!(result.unwrap_err(), "invalid_parent_hash");
}

#[test]
fn test_block_invalid_timestamp() {
    // Block with future timestamp should fail
    let mut node = TestNode::new();
    let mut block = node.create_valid_block();
    block.header.timestamp = node.current_time() + 3600; // 1 hour in future

    let result = node.validate_block(&block);
    assert!(result.is_err(), "Future timestamp should fail");
}

#[test]
fn test_block_timestamp_too_old() {
    // Block with timestamp before parent should fail
    let mut node = TestNode::new();
    let parent = node.get_best_block();
    let mut block = node.create_valid_block();
    block.header.timestamp = parent.header.timestamp - 1;

    let result = node.validate_block(&block);
    assert!(result.is_err(), "Timestamp before parent should fail");
}

#[test]
fn test_block_invalid_merkle_root() {
    // Block with wrong merkle root should fail
    let mut node = TestNode::new();
    let mut block = node.create_valid_block();
    block.header.transactions_root = [0xFFu8; 32];

    let result = node.validate_block(&block);
    assert!(result.is_err(), "Wrong merkle root should fail");
}

#[test]
fn test_block_exceeds_gas_limit() {
    // Block exceeding gas limit should fail
    let mut node = TestNode::new();
    let mut block = node.create_valid_block();
    // Add transactions that exceed block gas limit
    for _ in 0..1000 {
        block.transactions.push(node.create_heavy_tx());
    }

    let result = node.validate_block(&block);
    assert!(result.is_err(), "Block exceeding gas limit should fail");
}

#[test]
fn test_block_invalid_difficulty() {
    // Block with wrong difficulty should fail
    let mut node = TestNode::new();
    let mut block = node.create_valid_block();
    block.header.difficulty = 1; // Too low

    let result = node.validate_block(&block);
    assert!(result.is_err(), "Wrong difficulty should fail");
}

#[test]
fn test_block_invalid_nonce() {
    // Block with invalid PoW nonce should fail
    let mut node = TestNode::new();
    let mut block = node.create_valid_block();
    block.header.nonce = 0; // Invalid nonce

    let result = node.validate_block(&block);
    assert!(result.is_err(), "Invalid PoW should fail");
}

// =============================================================================
// Transaction Validation Tests
// =============================================================================

#[test]
fn test_tx_valid_signature() {
    // Transaction with valid signature should pass
    let mut node = TestNode::new();
    let tx = node.create_signed_tx();

    let result = node.validate_transaction(&tx);
    assert!(result.is_ok(), "Valid signature should pass");
}

#[test]
fn test_tx_invalid_signature() {
    // Transaction with invalid signature should fail
    let mut node = TestNode::new();
    let mut tx = node.create_signed_tx();
    tx.signature.r[0] ^= 0xFF; // Corrupt signature

    let result = node.validate_transaction(&tx);
    assert!(result.is_err(), "Invalid signature should fail");
}

#[test]
fn test_tx_insufficient_balance() {
    // Transaction with insufficient balance should fail
    let mut node = TestNode::new();
    let sender = node.create_account_with_balance(100);
    let tx = node.create_tx_from(&sender, 1000); // More than balance

    let result = node.validate_transaction(&tx);
    assert!(result.is_err(), "Insufficient balance should fail");
}

#[test]
fn test_tx_invalid_nonce() {
    // Transaction with wrong nonce should fail
    let mut node = TestNode::new();
    let sender = node.create_account();
    let tx = node.create_tx_with_nonce(&sender, 5); // Nonce gap

    let result = node.validate_transaction(&tx);
    assert!(result.is_err(), "Wrong nonce should fail");
}

#[test]
fn test_tx_gas_price_too_low() {
    // Transaction below min gas price should fail
    let mut node = TestNode::new();
    node.set_min_gas_price(1000000000);
    let tx = node.create_tx_with_gas_price(1); // Too low

    let result = node.validate_transaction(&tx);
    assert!(result.is_err(), "Gas price too low should fail");
}

#[test]
fn test_tx_intrinsic_gas() {
    // Transaction with insufficient gas for intrinsic cost should fail
    let mut node = TestNode::new();
    let tx = node.create_tx_with_gas(100); // Less than 21000

    let result = node.validate_transaction(&tx);
    assert!(result.is_err(), "Insufficient intrinsic gas should fail");
}

// =============================================================================
// Chain Selection Tests
// =============================================================================

#[test]
fn test_chain_selection_longest() {
    // Longer chain should be selected
    let mut node = TestNode::new();
    let chain_a = node.create_chain(10);
    let chain_b = node.create_chain(15);

    node.process_chain(&chain_a);
    node.process_chain(&chain_b);

    assert_eq!(node.best_chain_height(), 15);
}

#[test]
fn test_chain_selection_more_work() {
    // Chain with more work should be selected (same height)
    let mut node = TestNode::new();
    let chain_a = node.create_chain_with_difficulty(10, 100);
    let chain_b = node.create_chain_with_difficulty(10, 200);

    node.process_chain(&chain_a);
    node.process_chain(&chain_b);

    assert_eq!(node.best_chain_work(), chain_b.total_work());
}

#[test]
fn test_reorg_shallow() {
    // Shallow reorg should succeed
    let mut node = TestNode::new();
    let main_chain = node.create_chain(10);
    node.process_chain(&main_chain);

    let fork_chain = node.create_fork_at(8, 5); // Fork at height 8, 5 blocks
    node.process_chain(&fork_chain);

    assert_eq!(node.best_chain_height(), 13);
}

#[test]
fn test_reorg_deep_rejected() {
    // Deep reorg without sufficient work should be rejected
    let mut node = TestNode::new();
    node.set_max_reorg_depth(10);

    let main_chain = node.create_chain(100);
    node.process_chain(&main_chain);

    let fork_chain = node.create_fork_at(50, 55); // 50 block deep reorg
    let result = node.process_chain(&fork_chain);

    assert!(result.is_err(), "Deep reorg without extra work should fail");
}

// =============================================================================
// Finality Tests
// =============================================================================

#[test]
fn test_finality_depth() {
    // Block should be final after confirmation depth
    let mut node = TestNode::new();
    node.set_finality_depth(6);

    let chain = node.create_chain(10);
    node.process_chain(&chain);

    assert!(node.is_final(chain[3].hash()), "Block with 7 confirmations should be final");
    assert!(!node.is_final(chain[8].hash()), "Block with 2 confirmations should not be final");
}

#[test]
fn test_finality_prevents_reorg() {
    // Cannot reorg past finality
    let mut node = TestNode::new();
    node.set_finality_depth(6);

    let main_chain = node.create_chain(20);
    node.process_chain(&main_chain);

    let fork_chain = node.create_fork_at(5, 20); // Before finality
    let result = node.process_chain(&fork_chain);

    assert!(result.is_err(), "Reorg past finality should fail");
}

// =============================================================================
// Difficulty Adjustment Tests
// =============================================================================

#[test]
fn test_difficulty_adjustment_too_fast() {
    // Difficulty should increase if blocks too fast
    let mut node = TestNode::new();
    node.set_target_block_time(10);

    // Mine blocks faster than target
    for _ in 0..100 {
        node.mine_block_with_time(5); // 5 seconds instead of 10
    }

    let initial_diff = node.get_difficulty_at(0);
    let final_diff = node.get_difficulty_at(100);

    assert!(final_diff > initial_diff, "Difficulty should increase");
}

#[test]
fn test_difficulty_adjustment_too_slow() {
    // Difficulty should decrease if blocks too slow
    let mut node = TestNode::new();
    node.set_target_block_time(10);

    // Mine blocks slower than target
    for _ in 0..100 {
        node.mine_block_with_time(20); // 20 seconds instead of 10
    }

    let initial_diff = node.get_difficulty_at(0);
    let final_diff = node.get_difficulty_at(100);

    assert!(final_diff < initial_diff, "Difficulty should decrease");
}

#[test]
fn test_difficulty_adjustment_bounds() {
    // Difficulty adjustment should be bounded
    let mut node = TestNode::new();
    node.set_adjustment_factor(4); // Max 4x change

    // Mine very fast
    for _ in 0..100 {
        node.mine_block_with_time(1);
    }

    let diff_ratio = node.get_difficulty_at(100) as f64 / node.get_difficulty_at(0) as f64;
    assert!(diff_ratio <= 4.0, "Difficulty change should be bounded");
}

// =============================================================================
// State Root Tests
// =============================================================================

#[test]
fn test_state_root_deterministic() {
    // Same transactions should produce same state root
    let mut node1 = TestNode::new();
    let mut node2 = TestNode::new();

    let txs = vec![
        node1.create_transfer_tx(1, 2, 100),
        node1.create_transfer_tx(2, 3, 50),
    ];

    node1.execute_transactions(&txs);
    node2.execute_transactions(&txs);

    assert_eq!(node1.state_root(), node2.state_root());
}

#[test]
fn test_state_root_order_dependent() {
    // Different order should produce different state root
    let mut node1 = TestNode::new();
    let mut node2 = TestNode::new();

    let tx1 = node1.create_transfer_tx(1, 2, 100);
    let tx2 = node1.create_transfer_tx(1, 3, 100);

    node1.execute_transactions(&[tx1.clone(), tx2.clone()]);
    node2.execute_transactions(&[tx2, tx1]);

    // May or may not be equal depending on balance interactions
}
