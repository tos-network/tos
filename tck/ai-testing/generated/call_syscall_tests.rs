//! AI-Generated Call Syscall Tests
//!
//! Generated by Claude Code for TOS-TCK
//! Tests for CALL, DELEGATECALL, STATICCALL, CREATE, CREATE2 syscalls

use tos_tck::test_utils::{
    Address, TestEnv, CallResult,
    compute_contract_address, compute_create2_address,
    encode_set_storage, encode_write_storage, encode_transfer,
    encode_emit_log, encode_create, encode_selfdestruct, decode_u256,
};

// =============================================================================
// CALL Tests (18 tests)
// =============================================================================

#[test]
fn test_call_basic() {
    // Basic call to another contract
    let mut env = TestEnv::new();
    let target = env.deploy_contract("target_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.call_contract(&caller, &target, vec![], 0, 100000);
    assert!(result.success, "Basic call should succeed");
}

#[test]
fn test_call_with_value() {
    // Call with value transfer
    let mut env = TestEnv::new();
    let target = env.deploy_contract("target_contract");
    let caller = env.deploy_contract_with_balance("caller_contract", 1000);

    let result = env.call_contract(&caller, &target, vec![], 500, 100000);
    assert!(result.success, "Call with value should succeed");
    assert_eq!(env.get_balance(&target), 500);
}

#[test]
fn test_call_insufficient_balance() {
    // Call with insufficient balance should fail
    let mut env = TestEnv::new();
    let target = env.deploy_contract("target_contract");
    let caller = env.deploy_contract_with_balance("caller_contract", 100);

    let result = env.call_contract(&caller, &target, vec![], 500, 100000);
    assert!(!result.success, "Call with insufficient balance should fail");
}

#[test]
fn test_call_to_eoa() {
    // Call to EOA should succeed (just transfer)
    let mut env = TestEnv::new();
    let eoa = env.create_eoa();
    let caller = env.deploy_contract_with_balance("caller_contract", 1000);

    let result = env.call_contract(&caller, &eoa, vec![], 500, 100000);
    assert!(result.success, "Call to EOA should succeed");
    assert_eq!(env.get_balance(&eoa), 500);
}

#[test]
fn test_call_to_nonexistent() {
    // Call to nonexistent address should succeed (creates empty account)
    let mut env = TestEnv::new();
    let nonexistent = Address::from([0x42u8; 20]);
    let caller = env.deploy_contract_with_balance("caller_contract", 1000);

    let result = env.call_contract(&caller, &nonexistent, vec![], 500, 100000);
    assert!(result.success, "Call to nonexistent should succeed");
}

#[test]
fn test_call_return_data() {
    // Call should return data from callee
    let mut env = TestEnv::new();
    let target = env.deploy_contract("returning_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.call_contract(&caller, &target, vec![0x01], 0, 100000);
    assert!(!result.return_data.is_empty(), "Should return data");
}

#[test]
fn test_call_revert() {
    // Call to reverting contract should return false
    let mut env = TestEnv::new();
    let target = env.deploy_contract("reverting_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.call_contract(&caller, &target, vec![], 0, 100000);
    assert!(!result.success, "Call to reverting contract should fail");
}

#[test]
fn test_call_out_of_gas() {
    // Call with insufficient gas should fail
    let mut env = TestEnv::new();
    let target = env.deploy_contract("expensive_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.call_contract(&caller, &target, vec![], 0, 100);
    assert!(!result.success, "Call with insufficient gas should fail");
}

#[test]
fn test_call_gas_forwarding() {
    // Call should forward gas correctly (63/64 rule)
    let mut env = TestEnv::new();
    let target = env.deploy_contract("gas_checking_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.call_contract(&caller, &target, vec![], 0, 1000000);
    assert!(result.success);
    // Check that at least 63/64 of available gas was forwarded
}

#[test]
fn test_call_depth_limit() {
    // Recursive calls should respect depth limit (1024)
    let mut env = TestEnv::new();
    let recursive = env.deploy_contract("recursive_contract");

    let result = env.call_recursive(&recursive, 1025);
    assert!(!result.success, "Calls exceeding depth limit should fail");
}

// =============================================================================
// DELEGATECALL Tests (8 tests)
// =============================================================================

#[test]
fn test_delegatecall_basic() {
    // Delegatecall executes code in caller's context
    let mut env = TestEnv::new();
    let library = env.deploy_contract("library_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.delegatecall_contract(&caller, &library, vec![]);
    assert!(result.success, "Delegatecall should succeed");
}

#[test]
fn test_delegatecall_storage() {
    // Delegatecall should modify caller's storage
    let mut env = TestEnv::new();
    let library = env.deploy_contract("storage_library");
    let caller = env.deploy_contract("caller_contract");

    env.delegatecall_contract(&caller, &library, encode_set_storage([1u8; 32], [42u8; 32]));

    // Check caller's storage was modified
    let result = env.read_storage(&caller, [1u8; 32]);
    assert_eq!(result, [42u8; 32], "Caller's storage should be modified");
}

#[test]
fn test_delegatecall_preserves_msg_sender() {
    // Delegatecall should preserve msg.sender
    let mut env = TestEnv::new();
    let library = env.deploy_contract("sender_checking_library");
    let caller = env.deploy_contract("caller_contract");

    env.set_caller(Address::from([0x01u8; 20]));
    let result = env.delegatecall_contract(&caller, &library, vec![]);

    // Return data should be original caller
    assert_eq!(result.return_data, Address::from([0x01u8; 20]).as_bytes());
}

#[test]
fn test_delegatecall_preserves_msg_value() {
    // Delegatecall should preserve msg.value
    let mut env = TestEnv::new();
    let library = env.deploy_contract("value_checking_library");
    let caller = env.deploy_contract_with_balance("caller_contract", 1000);

    env.set_call_value(500);
    let result = env.delegatecall_contract(&caller, &library, vec![]);

    // Return data should be original value
    assert_eq!(decode_u256(&result.return_data), 500);
}

#[test]
fn test_delegatecall_no_value_transfer() {
    // Delegatecall cannot send value
    let mut env = TestEnv::new();
    let library = env.deploy_contract("library_contract");
    let caller = env.deploy_contract_with_balance("caller_contract", 1000);
    let initial_lib_balance = env.get_balance(&library);

    env.delegatecall_contract(&caller, &library, vec![]);

    assert_eq!(env.get_balance(&library), initial_lib_balance, "Library balance unchanged");
}

// =============================================================================
// STATICCALL Tests (6 tests)
// =============================================================================

#[test]
fn test_staticcall_basic() {
    // Staticcall should succeed for read-only operations
    let mut env = TestEnv::new();
    let target = env.deploy_contract("view_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.staticcall_contract(&caller, &target, vec![]);
    assert!(result.success, "Staticcall should succeed");
}

#[test]
fn test_staticcall_prevents_storage_write() {
    // Staticcall should prevent storage writes
    let mut env = TestEnv::new();
    let target = env.deploy_contract("writing_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.staticcall_contract(&caller, &target, encode_write_storage());
    assert!(!result.success, "Staticcall with storage write should fail");
}

#[test]
fn test_staticcall_prevents_value_transfer() {
    // Staticcall should prevent value transfer
    let mut env = TestEnv::new();
    let target = env.deploy_contract("transferring_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.staticcall_contract(&caller, &target, encode_transfer());
    assert!(!result.success, "Staticcall with value transfer should fail");
}

#[test]
fn test_staticcall_prevents_log() {
    // Staticcall should prevent LOG operations
    let mut env = TestEnv::new();
    let target = env.deploy_contract("logging_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.staticcall_contract(&caller, &target, encode_emit_log());
    assert!(!result.success, "Staticcall with LOG should fail");
}

#[test]
fn test_staticcall_prevents_create() {
    // Staticcall should prevent CREATE operations
    let mut env = TestEnv::new();
    let target = env.deploy_contract("creating_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.staticcall_contract(&caller, &target, encode_create());
    assert!(!result.success, "Staticcall with CREATE should fail");
}

#[test]
fn test_staticcall_prevents_selfdestruct() {
    // Staticcall should prevent SELFDESTRUCT
    let mut env = TestEnv::new();
    let target = env.deploy_contract("selfdestructing_contract");
    let caller = env.deploy_contract("caller_contract");

    let result = env.staticcall_contract(&caller, &target, encode_selfdestruct());
    assert!(!result.success, "Staticcall with SELFDESTRUCT should fail");
}

// =============================================================================
// CREATE Tests (10 tests)
// =============================================================================

#[test]
fn test_create_basic() {
    // Basic contract creation
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("factory_contract");

    let result = env.call_create(&factory, get_simple_bytecode(), 0);
    assert!(result.success, "CREATE should succeed");
    assert!(result.address.is_some(), "Should return new address");
}

#[test]
fn test_create_with_value() {
    // Create contract with initial balance
    let mut env = TestEnv::new();
    let factory = env.deploy_contract_with_balance("factory_contract", 1000);

    let result = env.call_create(&factory, get_simple_bytecode(), 500);
    assert!(result.success);
    assert_eq!(env.get_balance(&result.address.unwrap()), 500);
}

#[test]
fn test_create_address_deterministic() {
    // CREATE address is deterministic (sender + nonce)
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("factory_contract");

    let expected_addr = compute_create_address(&factory, 0);
    let result = env.call_create(&factory, get_simple_bytecode(), 0);

    assert_eq!(result.address.unwrap(), expected_addr);
}

#[test]
fn test_create_increments_nonce() {
    // CREATE should increment creator's nonce
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("factory_contract");

    let nonce_before = env.get_nonce(&factory);
    env.call_create(&factory, get_simple_bytecode(), 0);
    let nonce_after = env.get_nonce(&factory);

    assert_eq!(nonce_after, nonce_before + 1);
}

#[test]
fn test_create_collision_fails() {
    // CREATE at existing address should fail
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("factory_contract");

    // First create succeeds
    let result1 = env.call_create(&factory, get_simple_bytecode(), 0);
    assert!(result1.success);

    // Force nonce back (simulate collision)
    env.set_nonce(&factory, 0);

    let result2 = env.call_create(&factory, get_simple_bytecode(), 0);
    assert!(!result2.success, "CREATE at existing address should fail");
}

// =============================================================================
// CREATE2 Tests (8 tests)
// =============================================================================

#[test]
fn test_create2_basic() {
    // Basic CREATE2 deployment
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("factory_contract");
    let salt = [0x42u8; 32];

    let result = env.call_create2(&factory, get_simple_bytecode(), salt, 0);
    assert!(result.success, "CREATE2 should succeed");
}

#[test]
fn test_create2_deterministic_address() {
    // CREATE2 address is deterministic (sender + salt + init_code_hash)
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("factory_contract");
    let salt = [0x42u8; 32];
    let bytecode = get_simple_bytecode();

    let expected_addr = compute_create2_address(&factory, salt, &bytecode);
    let result = env.call_create2(&factory, bytecode, salt, 0);

    assert_eq!(result.address.unwrap(), expected_addr);
}

#[test]
fn test_create2_different_salt() {
    // Different salt produces different address
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("factory_contract");
    let bytecode = get_simple_bytecode();

    let result1 = env.call_create2(&factory, bytecode.clone(), [0x01u8; 32], 0);
    let result2 = env.call_create2(&factory, bytecode, [0x02u8; 32], 0);

    assert_ne!(result1.address, result2.address);
}

#[test]
fn test_create2_collision_fails() {
    // CREATE2 at existing address should fail
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("factory_contract");
    let salt = [0x42u8; 32];
    let bytecode = get_simple_bytecode();

    let result1 = env.call_create2(&factory, bytecode.clone(), salt, 0);
    assert!(result1.success);

    let result2 = env.call_create2(&factory, bytecode, salt, 0);
    assert!(!result2.success, "CREATE2 collision should fail");
}

#[test]
fn test_create2_same_salt_different_code() {
    // Same salt with different code produces different address
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("factory_contract");
    let salt = [0x42u8; 32];

    let result1 = env.call_create2(&factory, get_simple_bytecode(), salt, 0);
    let result2 = env.call_create2(&factory, get_different_bytecode(), salt, 0);

    assert_ne!(result1.address, result2.address);
}

// =============================================================================
// Helper Functions
// =============================================================================

fn get_simple_bytecode() -> Vec<u8> {
    // Simple contract: PUSH1 0 PUSH1 0 RETURN
    vec![0x60, 0x00, 0x60, 0x00, 0xF3]
}

fn get_different_bytecode() -> Vec<u8> {
    // Different simple contract
    vec![0x60, 0x01, 0x60, 0x00, 0xF3]
}

// Note: compute_contract_address, compute_create2_address, encode_*, decode_*
// are imported from tos_tck::test_utils
