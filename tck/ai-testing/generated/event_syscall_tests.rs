//! AI-Generated Event Syscall Tests
//!
//! Generated by Claude Code for TOS-TCK
//! Tests for LOG0-LOG4 event emission syscalls

use tos_tck::test_utils::*;

// =============================================================================
// LOG0 Tests (No topics)
// =============================================================================

#[test]
fn test_log0_basic() {
    // Basic LOG0 with data
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");
    let data = vec![0x42u8; 32];

    let result = env.call_log0(&contract, &data);
    assert!(result.success, "LOG0 should succeed");

    let logs = env.get_logs();
    assert_eq!(logs.len(), 1);
    assert_eq!(logs[0].topics.len(), 0);
    assert_eq!(logs[0].data, data);
}

#[test]
fn test_log0_empty_data() {
    // LOG0 with empty data
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");

    let result = env.call_log0(&contract, &[]);
    assert!(result.success);

    let logs = env.get_logs();
    assert_eq!(logs[0].data.len(), 0);
}

#[test]
fn test_log0_large_data() {
    // LOG0 with large data
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");
    let data = vec![0xABu8; 1024];

    let result = env.call_log0(&contract, &data);
    assert!(result.success);
    assert_eq!(env.get_logs()[0].data.len(), 1024);
}

// =============================================================================
// LOG1 Tests (1 topic)
// =============================================================================

#[test]
fn test_log1_basic() {
    // Basic LOG1 with one topic
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");
    let topic = [0x42u8; 32];
    let data = vec![0x01, 0x02, 0x03];

    let result = env.call_log1(&contract, &topic, &data);
    assert!(result.success);

    let logs = env.get_logs();
    assert_eq!(logs[0].topics.len(), 1);
    assert_eq!(logs[0].topics[0], topic);
    assert_eq!(logs[0].data, data);
}

#[test]
fn test_log1_event_signature() {
    // LOG1 with event signature as topic
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");
    // Transfer(address,address,uint256) signature
    let topic = keccak256(b"Transfer(address,address,uint256)");
    let data = encode_transfer_data(
        Address::from([0x01u8; 20]),
        Address::from([0x02u8; 20]),
        1000
    );

    let result = env.call_log1(&contract, &topic, &data);
    assert!(result.success);

    let logs = env.get_logs();
    assert_eq!(logs[0].topics[0], topic);
}

// =============================================================================
// LOG2 Tests (2 topics)
// =============================================================================

#[test]
fn test_log2_basic() {
    // Basic LOG2 with two topics
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");
    let topic1 = [0x42u8; 32];
    let topic2 = [0x43u8; 32];
    let data = vec![0x01, 0x02];

    let result = env.call_log2(&contract, &topic1, &topic2, &data);
    assert!(result.success);

    let logs = env.get_logs();
    assert_eq!(logs[0].topics.len(), 2);
    assert_eq!(logs[0].topics[0], topic1);
    assert_eq!(logs[0].topics[1], topic2);
}

#[test]
fn test_log2_indexed_event() {
    // LOG2 for indexed event (Transfer with indexed from)
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");
    let event_sig = keccak256(b"Transfer(address,address,uint256)");
    let from_topic = pad_address(Address::from([0x01u8; 20]));
    let data = encode_transfer_data_partial(Address::from([0x02u8; 20]), 1000);

    let result = env.call_log2(&contract, &event_sig, &from_topic, &data);
    assert!(result.success);
}

// =============================================================================
// LOG3 Tests (3 topics)
// =============================================================================

#[test]
fn test_log3_basic() {
    // Basic LOG3 with three topics
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");
    let topics = [[0x41u8; 32], [0x42u8; 32], [0x43u8; 32]];
    let data = vec![0x01];

    let result = env.call_log3(&contract, &topics[0], &topics[1], &topics[2], &data);
    assert!(result.success);

    let logs = env.get_logs();
    assert_eq!(logs[0].topics.len(), 3);
}

#[test]
fn test_log3_erc20_transfer() {
    // LOG3 for ERC20 Transfer (indexed from and to)
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("erc20_contract");
    let event_sig = keccak256(b"Transfer(address,address,uint256)");
    let from_topic = pad_address(Address::from([0x01u8; 20]));
    let to_topic = pad_address(Address::from([0x02u8; 20]));
    let data = encode_u256(1000);

    let result = env.call_log3(&contract, &event_sig, &from_topic, &to_topic, &data);
    assert!(result.success);
}

// =============================================================================
// LOG4 Tests (4 topics)
// =============================================================================

#[test]
fn test_log4_basic() {
    // Basic LOG4 with four topics
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");
    let topics = [[0x41u8; 32], [0x42u8; 32], [0x43u8; 32], [0x44u8; 32]];
    let data = vec![];

    let result = env.call_log4(&contract, &topics[0], &topics[1], &topics[2], &topics[3], &data);
    assert!(result.success);

    let logs = env.get_logs();
    assert_eq!(logs[0].topics.len(), 4);
}

#[test]
fn test_log4_max_topics() {
    // LOG4 is the maximum (4 topics)
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");
    let topics: Vec<[u8; 32]> = (0..4).map(|i| [i as u8; 32]).collect();

    let result = env.call_log4(&contract, &topics[0], &topics[1], &topics[2], &topics[3], &[]);
    assert!(result.success);
}

// =============================================================================
// Gas Tests
// =============================================================================

#[test]
fn test_log_gas_base_cost() {
    // Base gas cost for LOG
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");

    let gas_before = env.gas_remaining();
    env.call_log0(&contract, &[]);
    let gas_used = gas_before - env.gas_remaining();

    assert!(gas_used >= 375, "LOG0 base cost should be at least 375");
}

#[test]
fn test_log_gas_per_topic() {
    // Gas cost per topic (375 each)
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");

    let gas0 = measure_gas(|| env.call_log0(&contract, &[]));
    let gas1 = measure_gas(|| env.call_log1(&contract, &[0u8; 32], &[]));

    let topic_cost = gas1 - gas0;
    assert!(topic_cost >= 375, "Cost per topic should be at least 375");
}

#[test]
fn test_log_gas_per_data_byte() {
    // Gas cost per data byte (8 each)
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");

    let gas_empty = measure_gas(|| env.call_log0(&contract, &[]));
    let gas_32bytes = measure_gas(|| env.call_log0(&contract, &[0u8; 32]));

    let per_byte_cost = (gas_32bytes - gas_empty) / 32;
    assert!(per_byte_cost >= 8, "Cost per data byte should be at least 8");
}

// =============================================================================
// Static Context Tests
// =============================================================================

#[test]
fn test_log_in_static_context_fails() {
    // LOG operations in static context should fail
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");

    let result = env.staticcall_log0(&contract, &[0x42]);
    assert!(!result.success, "LOG in static context should fail");
}

// =============================================================================
// Multiple Logs Tests
// =============================================================================

#[test]
fn test_multiple_logs_same_tx() {
    // Multiple logs in same transaction
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_contract");

    env.call_log0(&contract, &[0x01]);
    env.call_log0(&contract, &[0x02]);
    env.call_log0(&contract, &[0x03]);

    let logs = env.get_logs();
    assert_eq!(logs.len(), 3);
    assert_eq!(logs[0].data, vec![0x01]);
    assert_eq!(logs[1].data, vec![0x02]);
    assert_eq!(logs[2].data, vec![0x03]);
}

#[test]
fn test_logs_from_nested_calls() {
    // Logs from nested calls are collected
    let mut env = TestEnv::new();
    let outer = env.deploy_contract("outer_contract");
    let inner = env.deploy_contract("inner_contract");

    // Outer calls inner, both emit logs
    env.call_nested_with_logs(&outer, &inner);

    let logs = env.get_logs();
    assert!(logs.len() >= 2, "Should collect logs from nested calls");
}

#[test]
fn test_logs_reverted_on_failure() {
    // Logs should be reverted if transaction fails
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("reverting_event_contract");

    env.call_log_then_revert(&contract, &[0x42]);

    let logs = env.get_logs();
    assert_eq!(logs.len(), 0, "Logs should be reverted on failure");
}

// =============================================================================
// Helper Functions
// =============================================================================

// All helper functions are imported from tos_tck::test_utils::*
// - keccak256(data) -> [u8; 32]
// - encode_transfer_data(from, to, amount) -> Vec<u8>
// - encode_transfer_data_partial(to, amount) -> Vec<u8>
// - pad_address(addr) -> [u8; 32]
// - encode_u256(value) -> [u8; 32]
// - measure_gas(closure) -> u64
