//! AI-Generated Edge Case Tests
//!
//! Generated by Claude Code for TOS-TCK
//! Tests for boundary conditions and edge cases

use tos_tck::test_utils::*;

// =============================================================================
// Numeric Boundary Tests
// =============================================================================

#[test]
fn test_uint256_max() {
    // Operations with max uint256
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("math_test");

    let max_u256 = [0xFFu8; 32];
    let result = env.call_store_and_load(&contract, max_u256);

    assert_eq!(result, max_u256);
}

#[test]
fn test_uint256_zero() {
    // Operations with zero
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("math_test");

    let zero = [0u8; 32];
    let result = env.call_store_and_load(&contract, zero);

    assert_eq!(result, zero);
}

#[test]
fn test_int256_min() {
    // Minimum signed int256 (-2^255)
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("signed_math_test");

    let mut min_int = [0u8; 32];
    min_int[0] = 0x80; // -2^255

    let result = env.call_store_and_load_signed(&contract, min_int);
    assert_eq!(result, min_int);
}

#[test]
fn test_int256_max() {
    // Maximum signed int256 (2^255 - 1)
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("signed_math_test");

    let mut max_int = [0xFFu8; 32];
    max_int[0] = 0x7F; // 2^255 - 1

    let result = env.call_store_and_load_signed(&contract, max_int);
    assert_eq!(result, max_int);
}

#[test]
fn test_division_by_zero() {
    // Division by zero returns zero in EVM
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("math_test");

    let result = env.call_div(&contract, [1u8; 32], [0u8; 32]);
    assert_eq!(result, [0u8; 32]);
}

#[test]
fn test_modulo_by_zero() {
    // Modulo by zero returns zero in EVM
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("math_test");

    let result = env.call_mod(&contract, [1u8; 32], [0u8; 32]);
    assert_eq!(result, [0u8; 32]);
}

// =============================================================================
// Address Edge Cases
// =============================================================================

#[test]
fn test_zero_address() {
    // Operations with zero address
    let mut env = TestEnv::new();
    let zero_addr = Address::zero();

    assert_eq!(env.get_balance(&zero_addr), 0);
    assert_eq!(env.get_code_size(&zero_addr), 0);
}

#[test]
fn test_precompile_addresses() {
    // Precompile addresses (0x01-0x09)
    let mut env = TestEnv::new();

    for i in 1u8..=9 {
        let mut addr_bytes = [0u8; 20];
        addr_bytes[19] = i;
        let precompile = Address::from(addr_bytes);

        // Precompiles have no code but special behavior
        assert_eq!(env.get_code_size(&precompile), 0);
    }
}

#[test]
fn test_max_address() {
    // Maximum address value
    let mut env = TestEnv::new();
    let max_addr = Address::from([0xFFu8; 20]);

    let result = env.get_balance(&max_addr);
    assert_eq!(result, 0);
}

// =============================================================================
// Gas Edge Cases
// =============================================================================

#[test]
fn test_zero_gas_call() {
    // Call with zero gas
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("simple_contract");

    let result = env.call_with_gas(&contract, 0);
    assert!(result.is_err());
}

#[test]
fn test_exact_gas_needed() {
    // Call with exact gas needed
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("fixed_gas_contract");

    // Contract needs exactly 50000 gas
    let result = env.call_with_gas(&contract, 50000);
    assert!(result.is_ok());
}

#[test]
fn test_max_gas() {
    // Call with maximum gas
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("simple_contract");

    let result = env.call_with_gas(&contract, u64::MAX);
    assert!(result.is_ok());
}

#[test]
fn test_gas_left_at_boundary() {
    // Check gas at 1/64 boundary
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("gas_checker");

    let result = env.call_check_gas_forwarding(&contract);
    // Should forward 63/64 of remaining gas
}

// =============================================================================
// Memory Edge Cases
// =============================================================================

#[test]
fn test_memory_at_max_offset() {
    // Memory operation at large offset
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("memory_test");

    // Very large offset (but still within gas limits)
    let result = env.call_mstore_at_offset(&contract, 1_000_000, [0x42u8; 32]);
    assert!(result.is_ok() || result.error_contains("out of gas"));
}

#[test]
fn test_memory_expansion_cost() {
    // Memory expansion has quadratic cost
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("memory_test");

    let gas_small = env.measure_gas(|| env.call_mstore_at_offset(&contract, 0, [0u8; 32]));
    let gas_large = env.measure_gas(|| env.call_mstore_at_offset(&contract, 10000, [0u8; 32]));

    assert!(gas_large > gas_small);
}

#[test]
fn test_empty_memory_read() {
    // Reading uninitialized memory returns zeros
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("memory_test");

    let result = env.call_mload_at_offset(&contract, 1000);
    assert_eq!(result, [0u8; 32]);
}

// =============================================================================
// Storage Edge Cases
// =============================================================================

#[test]
fn test_storage_key_zero() {
    // Storage at key 0
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");

    env.call_sstore(&contract, [0u8; 32], [42u8; 32]);
    let result = env.call_sload(&contract, [0u8; 32]);

    assert_eq!(result, [42u8; 32]);
}

#[test]
fn test_storage_key_max() {
    // Storage at max key
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");

    let max_key = [0xFFu8; 32];
    env.call_sstore(&contract, max_key, [42u8; 32]);
    let result = env.call_sload(&contract, max_key);

    assert_eq!(result, [42u8; 32]);
}

#[test]
fn test_storage_value_max() {
    // Max storage value
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("storage_test");

    let max_value = [0xFFu8; 32];
    env.call_sstore(&contract, [1u8; 32], max_value);
    let result = env.call_sload(&contract, [1u8; 32]);

    assert_eq!(result, max_value);
}

// =============================================================================
// Call Stack Edge Cases
// =============================================================================

#[test]
fn test_call_depth_1024() {
    // Maximum call depth is 1024
    let mut env = TestEnv::new();
    let recursive = env.deploy_contract("recursive_contract");

    let result = env.call_recursive(&recursive, 1024);
    assert!(result.is_ok());

    let result = env.call_recursive(&recursive, 1025);
    assert!(result.is_err());
}

#[test]
fn test_mutual_recursion() {
    // A calls B calls A...
    let mut env = TestEnv::new();
    let contract_a = env.deploy_contract("mutual_a");
    let contract_b = env.deploy_contract("mutual_b");

    env.setup_mutual_recursion(&contract_a, &contract_b);
    let result = env.call_mutual_recursive(&contract_a, 100);

    assert!(result.is_ok());
}

// =============================================================================
// Return Data Edge Cases
// =============================================================================

#[test]
fn test_return_data_empty() {
    // Empty return data
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("empty_return");

    let result = env.call_function(&contract, "noReturn");
    assert!(result.return_data.is_empty());
}

#[test]
fn test_return_data_large() {
    // Large return data
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("large_return");

    let result = env.call_function(&contract, "returnLargeData");
    assert!(result.return_data.len() > 1000);
}

#[test]
fn test_returndatacopy_beyond_size() {
    // RETURNDATACOPY beyond returndata size reverts
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("returndata_test");

    let result = env.call_returndatacopy_out_of_bounds(&contract);
    assert!(result.is_err());
}

// =============================================================================
// Timestamp/Block Number Edge Cases
// =============================================================================

#[test]
fn test_timestamp_zero() {
    // Timestamp of 0
    let mut env = TestEnv::new();
    env.set_timestamp(0);
    let contract = env.deploy_contract("time_test");

    let result = env.call_get_timestamp(&contract);
    assert_eq!(result, 0);
}

#[test]
fn test_timestamp_max() {
    // Maximum timestamp
    let mut env = TestEnv::new();
    env.set_timestamp(u64::MAX);
    let contract = env.deploy_contract("time_test");

    let result = env.call_get_timestamp(&contract);
    assert_eq!(result, u64::MAX);
}

#[test]
fn test_block_number_zero() {
    // Block number 0 (genesis)
    let mut env = TestEnv::new();
    env.set_block_number(0);
    let contract = env.deploy_contract("block_test");

    let result = env.call_get_block_number(&contract);
    assert_eq!(result, 0);
}

// =============================================================================
// Code Edge Cases
// =============================================================================

#[test]
fn test_extcodesize_zero() {
    // EXTCODESIZE of non-contract is 0
    let mut env = TestEnv::new();
    let eoa = env.create_account();
    let contract = env.deploy_contract("code_test");

    let result = env.call_extcodesize(&contract, &eoa);
    assert_eq!(result, 0);
}

#[test]
fn test_extcodecopy_empty() {
    // EXTCODECOPY of EOA copies zeros
    let mut env = TestEnv::new();
    let eoa = env.create_account();
    let contract = env.deploy_contract("code_test");

    let result = env.call_extcodecopy(&contract, &eoa, 0, 32);
    assert_eq!(result, [0u8; 32]);
}

#[test]
fn test_codecopy_beyond_code() {
    // CODECOPY beyond code size pads with zeros
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("code_test");
    let code_size = env.get_code_size(&contract);

    let result = env.call_codecopy(&contract, code_size, 32);
    assert_eq!(result, [0u8; 32]);
}

// =============================================================================
// Empty Input Edge Cases
// =============================================================================

#[test]
fn test_sha3_empty_input() {
    // SHA3 of empty input
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("hash_test");

    let result = env.call_sha3(&contract, &[]);
    // keccak256("") = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470
    assert_ne!(result, [0u8; 32]);
}

#[test]
fn test_calldata_empty() {
    // Empty calldata
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("calldata_test");

    let result = env.call_calldatasize(&contract, &[]);
    assert_eq!(result, 0);
}

#[test]
fn test_log_empty_data() {
    // LOG with empty data
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_test");

    let result = env.call_log0(&contract, &[]);
    assert!(result.is_ok());
}

// =============================================================================
// Nonce Edge Cases
// =============================================================================

#[test]
fn test_nonce_zero() {
    // First transaction has nonce 0
    let mut env = TestEnv::new();
    let account = env.create_account_with_balance(1000);

    assert_eq!(env.get_nonce(&account), 0);
}

#[test]
fn test_nonce_after_failed_tx() {
    // Nonce increments even on failed tx
    let mut env = TestEnv::new();
    let account = env.create_account_with_balance(1000);

    let nonce_before = env.get_nonce(&account);
    let _ = env.send_failing_transaction(&account);
    let nonce_after = env.get_nonce(&account);

    assert_eq!(nonce_after, nonce_before + 1);
}

#[test]
fn test_contract_nonce_after_create() {
    // Contract nonce starts at 1 after deployment
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("factory");

    // Contract's nonce is 1 (EIP-161)
    assert_eq!(env.get_nonce(&factory), 1);
}
