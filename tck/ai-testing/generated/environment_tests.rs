//! AI-Generated Environment Syscall Tests
//!
//! Generated by Claude Code for TOS-TCK
//! Tests for environment data syscalls

use tos_tck::test_utils::*;

// =============================================================================
// Address/Account Tests
// =============================================================================

#[test]
fn test_address_self() {
    // ADDRESS returns executing contract address
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("address_test");

    let result = env.call_address(&contract);
    assert_eq!(result, contract.address(), "Should return own address");
}

#[test]
fn test_caller_direct() {
    // CALLER returns immediate caller
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("caller_test");
    let user = env.create_eoa();

    env.set_caller(user);
    let result = env.call_caller(&contract);
    assert_eq!(result, user, "Should return caller address");
}

#[test]
fn test_caller_nested() {
    // CALLER in nested call returns intermediate contract
    let mut env = TestEnv::new();
    let outer = env.deploy_contract("outer_contract");
    let inner = env.deploy_contract("inner_caller_test");
    let user = env.create_eoa();

    env.set_caller(user);
    let result = env.nested_call_caller(&outer, &inner);
    assert_eq!(result, outer.address(), "Nested CALLER should be outer contract");
}

#[test]
fn test_origin() {
    // ORIGIN returns transaction originator
    let mut env = TestEnv::new();
    let outer = env.deploy_contract("outer_contract");
    let inner = env.deploy_contract("origin_test");
    let user = env.create_eoa();

    env.set_origin(user);
    let result = env.nested_call_origin(&outer, &inner);
    assert_eq!(result, user, "ORIGIN should be transaction originator");
}

#[test]
fn test_callvalue() {
    // CALLVALUE returns value sent with call
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("value_test");

    let result = env.call_with_value(&contract, 12345);
    assert_eq!(result, 12345, "Should return call value");
}

#[test]
fn test_callvalue_zero() {
    // CALLVALUE returns 0 when no value sent
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("value_test");

    let result = env.call_with_value(&contract, 0);
    assert_eq!(result, 0, "Should return zero");
}

// =============================================================================
// Calldata Tests
// =============================================================================

#[test]
fn test_calldatasize() {
    // CALLDATASIZE returns input data size
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("calldata_test");
    let data = vec![0x01, 0x02, 0x03, 0x04];

    let result = env.call_calldatasize(&contract, &data);
    assert_eq!(result, 4, "Should return calldata size");
}

#[test]
fn test_calldatasize_empty() {
    // CALLDATASIZE with no data returns 0
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("calldata_test");

    let result = env.call_calldatasize(&contract, &[]);
    assert_eq!(result, 0, "Empty calldata should have size 0");
}

#[test]
fn test_calldataload() {
    // CALLDATALOAD loads 32 bytes from calldata
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("calldata_test");
    let data = [0x42u8; 32];

    let result = env.call_calldataload(&contract, &data, 0);
    assert_eq!(result, data, "Should load 32 bytes from offset 0");
}

#[test]
fn test_calldataload_partial() {
    // CALLDATALOAD past end pads with zeros
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("calldata_test");
    let data = vec![0x01, 0x02, 0x03, 0x04];

    let result = env.call_calldataload(&contract, &data, 0);
    // First 4 bytes are data, rest is zeros
    assert_eq!(result[0..4], [0x01, 0x02, 0x03, 0x04]);
    assert_eq!(result[4..32], [0u8; 28]);
}

#[test]
fn test_calldatacopy() {
    // CALLDATACOPY copies calldata to memory
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("calldata_test");
    let data = vec![0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08];

    let result = env.call_calldatacopy(&contract, &data, 0, 4, 4);
    assert_eq!(result, [0x05, 0x06, 0x07, 0x08], "Should copy 4 bytes from offset 4");
}

// =============================================================================
// Block Information Tests
// =============================================================================

#[test]
fn test_blockhash() {
    // BLOCKHASH returns hash of recent block
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("block_test");

    env.mine_blocks(10);
    let current = env.block_number();
    let result = env.call_blockhash(&contract, current - 1);

    assert_ne!(result, [0u8; 32], "Should return non-zero hash");
}

#[test]
fn test_blockhash_too_old() {
    // BLOCKHASH returns 0 for blocks > 256 ago
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("block_test");

    env.mine_blocks(300);
    let current = env.block_number();
    let result = env.call_blockhash(&contract, current - 257);

    assert_eq!(result, [0u8; 32], "Old block hash should be zero");
}

#[test]
fn test_blockhash_future() {
    // BLOCKHASH returns 0 for future blocks
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("block_test");

    let current = env.block_number();
    let result = env.call_blockhash(&contract, current + 1);

    assert_eq!(result, [0u8; 32], "Future block hash should be zero");
}

#[test]
fn test_coinbase() {
    // COINBASE returns block miner address
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("block_test");
    let miner = Address::from([0x42u8; 20]);

    env.set_coinbase(miner);
    let result = env.call_coinbase(&contract);

    assert_eq!(result, miner, "Should return coinbase address");
}

#[test]
fn test_timestamp() {
    // TIMESTAMP returns block timestamp
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("block_test");

    env.set_timestamp(1234567890);
    let result = env.call_timestamp(&contract);

    assert_eq!(result, 1234567890, "Should return timestamp");
}

#[test]
fn test_number() {
    // NUMBER returns block number
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("block_test");

    env.set_block_number(42);
    let result = env.call_number(&contract);

    assert_eq!(result, 42, "Should return block number");
}

#[test]
fn test_difficulty() {
    // DIFFICULTY returns block difficulty
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("block_test");

    env.set_difficulty(1000000);
    let result = env.call_difficulty(&contract);

    assert_eq!(result, 1000000, "Should return difficulty");
}

#[test]
fn test_gaslimit() {
    // GASLIMIT returns block gas limit
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("block_test");

    env.set_gas_limit(30000000);
    let result = env.call_gaslimit(&contract);

    assert_eq!(result, 30000000, "Should return gas limit");
}

#[test]
fn test_chainid() {
    // CHAINID returns chain ID
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("block_test");

    env.set_chain_id(1);
    let result = env.call_chainid(&contract);

    assert_eq!(result, 1, "Should return chain ID");
}

#[test]
fn test_basefee() {
    // BASEFEE returns base fee (EIP-1559)
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("block_test");

    env.set_base_fee(1000000000); // 1 gwei
    let result = env.call_basefee(&contract);

    assert_eq!(result, 1000000000, "Should return base fee");
}

// =============================================================================
// Gas Tests
// =============================================================================

#[test]
fn test_gas() {
    // GAS returns remaining gas
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("gas_test");

    let result = env.call_gas(&contract, 1000000);
    assert!(result > 0 && result < 1000000, "Should return remaining gas");
}

#[test]
fn test_gasprice() {
    // GASPRICE returns transaction gas price
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("gas_test");

    env.set_gas_price(20000000000); // 20 gwei
    let result = env.call_gasprice(&contract);

    assert_eq!(result, 20000000000, "Should return gas price");
}

// =============================================================================
// Self Balance Tests
// =============================================================================

#[test]
fn test_selfbalance() {
    // SELFBALANCE returns contract's own balance
    let mut env = TestEnv::new();
    let contract = env.deploy_contract_with_balance("balance_test", 1000);

    let result = env.call_selfbalance(&contract);
    assert_eq!(result, 1000, "Should return own balance");
}

#[test]
fn test_selfbalance_after_receive() {
    // SELFBALANCE updates after receiving value
    let mut env = TestEnv::new();
    let contract = env.deploy_contract_with_balance("balance_test", 1000);

    env.send_value(&contract, 500);
    let result = env.call_selfbalance(&contract);

    assert_eq!(result, 1500, "Should reflect received value");
}
