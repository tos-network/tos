//! AI-Generated Reentrancy Security Tests
//!
//! Generated by Claude Code for TOS-TCK
//! Tests for reentrancy attack detection and prevention

use tos_tck::test_utils::*;

// =============================================================================
// Basic Reentrancy Tests
// =============================================================================

#[test]
fn test_reentrancy_attack_detected() {
    // Basic reentrancy attack should be detected
    let mut env = TestEnv::new();
    let victim = env.deploy_contract_with_balance("vulnerable_bank", 10000);
    let attacker = env.deploy_contract("reentrancy_attacker");

    // Attacker deposits
    env.call_deposit(&victim, &attacker, 100);

    // Attacker exploits
    let result = env.call_withdraw(&victim, &attacker);

    // Should either fail or drain was prevented
    assert!(
        result.is_err() || env.get_balance(&victim) > 0,
        "Reentrancy attack should be prevented"
    );
}

#[test]
fn test_reentrancy_guard_works() {
    // Contract with reentrancy guard should be safe
    let mut env = TestEnv::new();
    let safe_bank = env.deploy_contract_with_balance("safe_bank", 10000);
    let attacker = env.deploy_contract("reentrancy_attacker");

    env.call_deposit(&safe_bank, &attacker, 100);
    let result = env.call_withdraw(&safe_bank, &attacker);

    assert!(result.is_err(), "Reentrancy guard should prevent attack");
    assert_eq!(
        env.get_balance(&safe_bank),
        10000,
        "Bank balance should be unchanged"
    );
}

#[test]
fn test_checks_effects_interactions_pattern() {
    // CEI pattern prevents reentrancy
    let mut env = TestEnv::new();
    let cei_contract = env.deploy_contract_with_balance("cei_bank", 10000);
    let attacker = env.deploy_contract("reentrancy_attacker");

    env.call_deposit(&cei_contract, &attacker, 100);
    env.call_withdraw(&cei_contract, &attacker);

    // Even without explicit guard, CEI prevents exploitation
    assert!(
        env.get_balance(&cei_contract) >= 9900,
        "CEI pattern should prevent drain"
    );
}

// =============================================================================
// Cross-Function Reentrancy Tests
// =============================================================================

#[test]
fn test_cross_function_reentrancy() {
    // Reentrancy across different functions
    let mut env = TestEnv::new();
    let victim = env.deploy_contract_with_balance("multi_function_bank", 10000);
    let attacker = env.deploy_contract("cross_function_attacker");

    env.call_deposit(&victim, &attacker, 100);

    // Attacker calls withdraw, which calls transfer in callback
    let result = env.call_withdraw_to_attacker(&victim, &attacker);

    assert!(result.is_err(), "Cross-function reentrancy should be prevented");
}

#[test]
fn test_cross_contract_reentrancy() {
    // Reentrancy across contracts
    let mut env = TestEnv::new();
    let vault = env.deploy_contract_with_balance("vault", 10000);
    let token = env.deploy_contract("token");
    let attacker = env.deploy_contract("cross_contract_attacker");

    // Complex cross-contract reentrancy
    env.setup_cross_contract_attack(&vault, &token, &attacker);
    let result = env.execute_attack(&attacker);

    assert!(result.is_err() || env.total_value_unchanged(&vault, &token));
}

// =============================================================================
// Read-Only Reentrancy Tests
// =============================================================================

#[test]
fn test_read_only_reentrancy() {
    // Read-only reentrancy detection
    let mut env = TestEnv::new();
    let oracle = env.deploy_contract("price_oracle");
    let lending = env.deploy_contract_with_balance("lending_protocol", 10000);
    let attacker = env.deploy_contract("readonly_attacker");

    // Attacker tries to manipulate oracle reading during callback
    let result = env.execute_readonly_attack(&attacker, &oracle, &lending);

    assert!(result.is_err(), "Read-only reentrancy should be prevented");
}

#[test]
fn test_view_function_reentrancy() {
    // View function called during state change
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("stateful_contract");
    let attacker = env.deploy_contract("view_reentrancy_attacker");

    // View function should see consistent state
    let result = env.call_view_during_modification(&contract, &attacker);

    assert!(
        result.state_consistent,
        "View function should see consistent state"
    );
}

// =============================================================================
// ERC20/ERC721 Callback Reentrancy Tests
// =============================================================================

#[test]
fn test_erc721_on_received_reentrancy() {
    // ERC721 onERC721Received callback reentrancy
    let mut env = TestEnv::new();
    let nft = env.deploy_contract("erc721_token");
    let victim = env.deploy_contract_with_balance("nft_marketplace", 10000);
    let attacker = env.deploy_contract("nft_attacker");

    env.mint_nft(&nft, &attacker, 1);
    let result = env.exploit_nft_callback(&victim, &attacker, &nft, 1);

    assert!(result.is_err(), "ERC721 callback reentrancy should be prevented");
}

#[test]
fn test_erc777_hook_reentrancy() {
    // ERC777 token hook reentrancy
    let mut env = TestEnv::new();
    let token = env.deploy_contract("erc777_token");
    let victim = env.deploy_contract_with_balance("token_exchange", 10000);
    let attacker = env.deploy_contract("erc777_attacker");

    let result = env.exploit_erc777_hook(&victim, &attacker, &token);

    assert!(result.is_err(), "ERC777 hook reentrancy should be prevented");
}

// =============================================================================
// Reentrancy Lock Tests
// =============================================================================

#[test]
fn test_mutex_lock_single_function() {
    // Single function mutex lock
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("mutex_contract");
    let attacker = env.deploy_contract("reentrancy_attacker");

    let result = env.reenter_locked_function(&contract, &attacker);
    assert!(result.is_err(), "Mutex should prevent reentry");
}

#[test]
fn test_mutex_lock_multiple_functions() {
    // Global mutex across multiple functions
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("global_mutex_contract");
    let attacker = env.deploy_contract("cross_function_attacker");

    let result = env.reenter_different_function(&contract, &attacker);
    assert!(result.is_err(), "Global mutex should prevent cross-function reentry");
}

#[test]
fn test_per_address_lock() {
    // Per-address reentrancy lock
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("per_address_lock_contract");
    let user1 = env.create_account();
    let user2 = env.create_account();

    // User1 locked, but user2 should be able to call
    env.start_operation(&contract, &user1);
    let result = env.call_function(&contract, &user2);

    assert!(result.is_ok(), "Per-address lock should allow different users");
}

// =============================================================================
// Gas-Based Reentrancy Tests
// =============================================================================

#[test]
fn test_gas_stipend_reentrancy() {
    // 2300 gas stipend limits reentrancy
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("transfer_contract");
    let attacker = env.deploy_contract("gas_limited_attacker");

    // Transfer only provides 2300 gas, not enough for reentry
    let result = env.transfer_with_stipend(&contract, &attacker, 1000);

    // Attacker cannot reenter with only 2300 gas
    assert!(result.is_ok(), "Transfer should complete");
    assert!(!env.reentrancy_attempted(&attacker), "Reentry should fail due to gas limit");
}

#[test]
fn test_call_with_gas_reentrancy() {
    // Call with explicit gas can enable reentrancy
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("high_gas_transfer_contract");
    let attacker = env.deploy_contract("reentrancy_attacker");

    // Contract forwards all gas
    let result = env.call_with_all_gas(&contract, &attacker);

    // This might enable reentrancy if not protected
    assert!(
        result.is_err() || env.has_reentrancy_protection(&contract),
        "High gas calls need protection"
    );
}

// =============================================================================
// State Consistency Tests
// =============================================================================

#[test]
fn test_invariant_during_callback() {
    // Invariants should hold during callbacks
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("invariant_contract");
    let callback_receiver = env.deploy_contract("callback_checker");

    env.call_with_callback(&contract, &callback_receiver);

    assert!(
        env.invariants_held(&contract),
        "Invariants should hold during callback"
    );
}

#[test]
fn test_balance_consistency_during_reentry() {
    // Balances should be consistent during reentry attempts
    let mut env = TestEnv::new();
    let bank = env.deploy_contract_with_balance("consistent_bank", 10000);
    let checker = env.deploy_contract("balance_checker");

    env.set_callback_receiver(&bank, &checker);
    env.call_withdraw(&bank, &checker);

    let balances_consistent = env.check_balance_consistency(&bank);
    assert!(balances_consistent, "Balances should be consistent");
}

// =============================================================================
// Defense Pattern Tests
// =============================================================================

#[test]
fn test_pull_payment_pattern() {
    // Pull payment pattern is reentrancy-safe
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("pull_payment_contract");
    let attacker = env.deploy_contract("reentrancy_attacker");

    // Record payment for attacker
    env.record_payment(&contract, &attacker, 1000);

    // Attacker pulls payment (no reentrancy possible)
    let result = env.pull_payment(&contract, &attacker);

    assert!(result.is_ok());
    assert_eq!(env.get_balance(&attacker), 1000);
}

#[test]
fn test_withdrawal_limit() {
    // Withdrawal limits can prevent reentrancy damage
    let mut env = TestEnv::new();
    let contract = env.deploy_contract_with_balance("limited_withdrawal", 10000);
    let attacker = env.deploy_contract("reentrancy_attacker");

    env.set_withdrawal_limit(&contract, 100);
    env.call_deposit(&contract, &attacker, 1000);

    // Even with reentrancy, damage is limited
    env.attempt_exploit(&attacker, &contract);

    assert!(
        env.get_balance(&contract) >= 9000,
        "Withdrawal limit should reduce damage"
    );
}
