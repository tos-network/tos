//! AI-Generated Test Suite: Balance Syscalls
//!
//! Generated by: Claude Code
//! Date: 2025-01-09
//! Prompt: prompts/syscall_test_generator.md
//!
//! Review status: APPROVED
//! Reviewer: TOS Team

use tos_tck::prelude::*;

// =============================================================================
// Happy Path Tests
// =============================================================================

/// Test: Get balance returns correct value
#[tokio::test]
async fn test_get_balance_returns_correct_value() {
    // Setup
    let blockchain = TestBlockchainBuilder::new()
        .with_account("alice", 1_000_000_000) // 1000 TOS
        .build()
        .await
        .expect("Failed to create test blockchain");

    // Execute
    let balance = blockchain.get_balance("alice").await;

    // Verify
    assert_eq!(balance, 1_000_000_000);
}

/// Test: Get balance of new account returns zero
#[tokio::test]
async fn test_get_balance_new_account_returns_zero() {
    let blockchain = TestBlockchainBuilder::new()
        .build()
        .await
        .expect("Failed to create test blockchain");

    let balance = blockchain.get_balance("nonexistent").await;

    assert_eq!(balance, 0);
}

/// Test: Transfer updates both balances correctly
#[tokio::test]
async fn test_transfer_updates_balances() {
    let blockchain = TestBlockchainBuilder::new()
        .with_account("alice", 1_000_000_000)
        .with_account("bob", 500_000_000)
        .build()
        .await
        .expect("Failed to create test blockchain");

    // Execute transfer
    let result = blockchain.transfer("alice", "bob", 100_000_000).await;
    assert!(result.is_ok());

    // Verify balances
    assert_eq!(blockchain.get_balance("alice").await, 900_000_000);
    assert_eq!(blockchain.get_balance("bob").await, 600_000_000);
}

// =============================================================================
// Edge Case Tests
// =============================================================================

/// Test: Transfer exact balance (drain account)
#[tokio::test]
async fn test_transfer_exact_balance() {
    let blockchain = TestBlockchainBuilder::new()
        .with_account("alice", 100_000_000)
        .with_account("bob", 0)
        .build()
        .await
        .expect("Failed to create test blockchain");

    let result = blockchain.transfer("alice", "bob", 100_000_000).await;
    assert!(result.is_ok());

    assert_eq!(blockchain.get_balance("alice").await, 0);
    assert_eq!(blockchain.get_balance("bob").await, 100_000_000);
}

/// Test: Transfer to self is rejected
#[tokio::test]
async fn test_transfer_to_self_rejected() {
    let blockchain = TestBlockchainBuilder::new()
        .with_account("alice", 1_000_000_000)
        .build()
        .await
        .expect("Failed to create test blockchain");

    let result = blockchain.transfer("alice", "alice", 100_000_000).await;

    assert!(result.is_err());
    // Balance should be unchanged
    assert_eq!(blockchain.get_balance("alice").await, 1_000_000_000);
}

/// Test: Transfer zero amount is rejected
#[tokio::test]
async fn test_transfer_zero_amount_rejected() {
    let blockchain = TestBlockchainBuilder::new()
        .with_account("alice", 1_000_000_000)
        .with_account("bob", 0)
        .build()
        .await
        .expect("Failed to create test blockchain");

    let result = blockchain.transfer("alice", "bob", 0).await;

    assert!(result.is_err());
}

// =============================================================================
// Error Case Tests
// =============================================================================

/// Test: Transfer with insufficient balance fails
#[tokio::test]
async fn test_transfer_insufficient_balance_fails() {
    let blockchain = TestBlockchainBuilder::new()
        .with_account("alice", 100_000_000)
        .with_account("bob", 0)
        .build()
        .await
        .expect("Failed to create test blockchain");

    let result = blockchain.transfer("alice", "bob", 200_000_000).await;

    assert!(result.is_err());
    // Balances should be unchanged
    assert_eq!(blockchain.get_balance("alice").await, 100_000_000);
    assert_eq!(blockchain.get_balance("bob").await, 0);
}

/// Test: Transfer from nonexistent account fails
#[tokio::test]
async fn test_transfer_from_nonexistent_fails() {
    let blockchain = TestBlockchainBuilder::new()
        .with_account("bob", 0)
        .build()
        .await
        .expect("Failed to create test blockchain");

    let result = blockchain.transfer("nonexistent", "bob", 100).await;

    assert!(result.is_err());
}

// =============================================================================
// Security Tests
// =============================================================================

/// Test: Balance overflow is prevented
#[tokio::test]
async fn test_balance_overflow_prevented() {
    let blockchain = TestBlockchainBuilder::new()
        .with_account("alice", 1_000_000)
        .with_account("bob", u64::MAX - 100)
        .build()
        .await
        .expect("Failed to create test blockchain");

    // Attempt to overflow bob's balance
    let result = blockchain.transfer("alice", "bob", 200).await;

    // Should fail with overflow error
    assert!(result.is_err());

    // Bob's balance should be unchanged (not wrapped)
    assert_eq!(blockchain.get_balance("bob").await, u64::MAX - 100);
}

/// Test: Balance underflow is prevented
#[tokio::test]
async fn test_balance_underflow_prevented() {
    let blockchain = TestBlockchainBuilder::new()
        .with_account("alice", 100)
        .with_account("bob", 0)
        .build()
        .await
        .expect("Failed to create test blockchain");

    // Attempt to underflow alice's balance
    let result = blockchain.transfer("alice", "bob", 200).await;

    // Should fail
    assert!(result.is_err());

    // Alice's balance should be unchanged (not wrapped to MAX)
    assert_eq!(blockchain.get_balance("alice").await, 100);
}

/// Test: Total supply is conserved after transfer
#[tokio::test]
async fn test_total_supply_conserved() {
    let initial_alice = 1_000_000_000u64;
    let initial_bob = 500_000_000u64;
    let total_supply = initial_alice + initial_bob;

    let blockchain = TestBlockchainBuilder::new()
        .with_account("alice", initial_alice)
        .with_account("bob", initial_bob)
        .build()
        .await
        .expect("Failed to create test blockchain");

    // Perform transfer
    let _ = blockchain.transfer("alice", "bob", 100_000_000).await;

    // Verify total supply is conserved
    let final_total = blockchain.get_balance("alice").await + blockchain.get_balance("bob").await;
    assert_eq!(final_total, total_supply);
}

// =============================================================================
// Boundary Tests
// =============================================================================

/// Test: Maximum balance value
#[tokio::test]
async fn test_max_balance() {
    let blockchain = TestBlockchainBuilder::new()
        .with_account("whale", u64::MAX)
        .build()
        .await
        .expect("Failed to create test blockchain");

    assert_eq!(blockchain.get_balance("whale").await, u64::MAX);
}

/// Test: Transfer 1 unit (minimum non-zero)
#[tokio::test]
async fn test_transfer_minimum_amount() {
    let blockchain = TestBlockchainBuilder::new()
        .with_account("alice", 1_000_000)
        .with_account("bob", 0)
        .build()
        .await
        .expect("Failed to create test blockchain");

    let result = blockchain.transfer("alice", "bob", 1).await;

    assert!(result.is_ok());
    assert_eq!(blockchain.get_balance("alice").await, 999_999);
    assert_eq!(blockchain.get_balance("bob").await, 1);
}
