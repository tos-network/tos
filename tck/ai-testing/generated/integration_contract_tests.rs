//! AI-Generated Contract Integration Tests
//!
//! Generated by Claude Code for TOS-TCK
//! Tests for contract deployment and interaction

use tos_tck::test_utils::*;

// =============================================================================
// Contract Deployment Tests
// =============================================================================

#[test]
fn test_deploy_simple_contract() {
    // Deploy a simple contract
    let mut env = TestEnv::new();
    let deployer = env.create_account_with_balance(1000000);

    let result = env.deploy_contract_from(&deployer, "simple_contract");

    assert!(result.is_ok());
    assert!(result.address.is_some());
}

#[test]
fn test_deploy_with_constructor() {
    // Deploy contract with constructor arguments
    let mut env = TestEnv::new();
    let deployer = env.create_account_with_balance(1000000);

    let result = env.deploy_contract_with_args(&deployer, "counter", vec![encode_u256(100)]);

    assert!(result.is_ok());
    // Verify initial value was set
    let contract = result.address.unwrap();
    assert_eq!(env.call_view(&contract, "getValue"), 100);
}

#[test]
fn test_deploy_with_value() {
    // Deploy contract with initial balance
    let mut env = TestEnv::new();
    let deployer = env.create_account_with_balance(1000000);

    let result = env.deploy_contract_with_value(&deployer, "payable_contract", 10000);

    assert!(result.is_ok());
    let contract = result.address.unwrap();
    assert_eq!(env.get_balance(&contract), 10000);
}

#[test]
fn test_deploy_insufficient_gas() {
    // Deploy with insufficient gas fails
    let mut env = TestEnv::new();
    let deployer = env.create_account_with_balance(1000000);

    let result = env.deploy_contract_with_gas(&deployer, "complex_contract", 10000);

    assert!(result.is_err());
}

#[test]
fn test_deploy_constructor_reverts() {
    // Constructor revert should fail deployment
    let mut env = TestEnv::new();
    let deployer = env.create_account_with_balance(1000000);

    let result = env.deploy_contract_from(&deployer, "reverting_constructor");

    assert!(result.is_err());
}

#[test]
fn test_deploy_address_deterministic() {
    // Deployed address is deterministic
    let mut env = TestEnv::new();
    let deployer = env.create_account_with_balance(1000000);

    let expected_addr = compute_contract_address(&deployer, 0);
    let result = env.deploy_contract_from(&deployer, "simple_contract");

    assert_eq!(result.address.unwrap(), expected_addr);
}

// =============================================================================
// Contract Call Tests
// =============================================================================

#[test]
fn test_call_view_function() {
    // Call view function
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("counter");

    let result = env.call_view(&contract, "getValue");

    assert!(result.is_ok());
}

#[test]
fn test_call_state_changing() {
    // Call state-changing function
    let mut env = TestEnv::new();
    let caller = env.create_account_with_balance(1000000);
    let contract = env.deploy_contract("counter");

    env.set_caller(caller);
    env.call_function(&contract, "increment");

    assert_eq!(env.call_view(&contract, "getValue"), 1);
}

#[test]
fn test_call_with_arguments() {
    // Call function with arguments
    let mut env = TestEnv::new();
    let caller = env.create_account_with_balance(1000000);
    let contract = env.deploy_contract("calculator");

    env.set_caller(caller);
    let result = env.call_function_with_args(&contract, "add", vec![10, 20]);

    assert_eq!(result.return_value, 30);
}

#[test]
fn test_call_payable_function() {
    // Call payable function with value
    let mut env = TestEnv::new();
    let caller = env.create_account_with_balance(1000000);
    let contract = env.deploy_contract("payable_contract");

    env.set_caller(caller);
    let result = env.call_function_with_value(&contract, "deposit", 1000);

    assert!(result.is_ok());
    assert_eq!(env.get_balance(&contract), 1000);
}

#[test]
fn test_call_nonpayable_with_value() {
    // Calling non-payable with value fails
    let mut env = TestEnv::new();
    let caller = env.create_account_with_balance(1000000);
    let contract = env.deploy_contract("nonpayable_contract");

    env.set_caller(caller);
    let result = env.call_function_with_value(&contract, "doSomething", 1000);

    assert!(result.is_err());
}

#[test]
fn test_call_reverts() {
    // Function revert is handled
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("reverting_contract");

    let result = env.call_function(&contract, "willRevert");

    assert!(result.is_err());
    assert!(result.revert_reason.contains("Reverted"));
}

// =============================================================================
// Contract Interaction Tests
// =============================================================================

#[test]
fn test_contract_to_contract_call() {
    // Contract A calls Contract B
    let mut env = TestEnv::new();
    let contract_a = env.deploy_contract("caller_contract");
    let contract_b = env.deploy_contract("callee_contract");

    let result = env.call_external(&contract_a, &contract_b, "getValue");

    assert!(result.is_ok());
}

#[test]
fn test_nested_contract_calls() {
    // A calls B calls C
    let mut env = TestEnv::new();
    let contract_a = env.deploy_contract("contract_a");
    let contract_b = env.deploy_contract("contract_b");
    let contract_c = env.deploy_contract("contract_c");

    let result = env.call_nested(&contract_a, &contract_b, &contract_c);

    assert!(result.is_ok());
}

#[test]
fn test_interface_call() {
    // Call through interface
    let mut env = TestEnv::new();
    let token = env.deploy_erc20("Token", "TKN", 1000000);
    let consumer = env.deploy_contract("token_consumer");

    let result = env.call_with_interface(&consumer, &token, "balanceOf");

    assert!(result.is_ok());
}

// =============================================================================
// Proxy Contract Tests
// =============================================================================

#[test]
fn test_proxy_delegate_call() {
    // Proxy delegates to implementation
    let mut env = TestEnv::new();
    let implementation = env.deploy_contract("implementation_v1");
    let proxy = env.deploy_proxy(&implementation);

    let result = env.call_through_proxy(&proxy, "getValue");

    assert!(result.is_ok());
}

#[test]
fn test_proxy_upgrade() {
    // Proxy can be upgraded
    let mut env = TestEnv::new();
    let admin = env.create_account();
    let impl_v1 = env.deploy_contract("implementation_v1");
    let impl_v2 = env.deploy_contract("implementation_v2");
    let proxy = env.deploy_upgradeable_proxy(&impl_v1, &admin);

    env.set_caller(admin);
    env.upgrade_proxy(&proxy, &impl_v2);

    let impl_address = env.get_implementation(&proxy);
    assert_eq!(impl_address, impl_v2.address());
}

#[test]
fn test_proxy_storage_preserved() {
    // Storage is preserved across upgrades
    let mut env = TestEnv::new();
    let admin = env.create_account();
    let impl_v1 = env.deploy_contract("implementation_v1");
    let impl_v2 = env.deploy_contract("implementation_v2");
    let proxy = env.deploy_upgradeable_proxy(&impl_v1, &admin);

    // Set value through v1
    env.call_through_proxy(&proxy, "setValue", vec![42]);

    // Upgrade to v2
    env.set_caller(admin);
    env.upgrade_proxy(&proxy, &impl_v2);

    // Value should be preserved
    let value = env.call_through_proxy(&proxy, "getValue");
    assert_eq!(value, 42);
}

// =============================================================================
// Factory Contract Tests
// =============================================================================

#[test]
fn test_factory_create() {
    // Factory creates new contracts
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("contract_factory");

    let result = env.call_factory_create(&factory);

    assert!(result.is_ok());
    assert!(result.created_address.is_some());
}

#[test]
fn test_factory_create2() {
    // Factory uses CREATE2 for deterministic addresses
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("create2_factory");
    let salt = [0x42u8; 32];

    let expected_addr = compute_create2_address(&factory, salt, get_bytecode("child"));
    let result = env.call_factory_create2(&factory, salt);

    assert_eq!(result.created_address.unwrap(), expected_addr);
}

#[test]
fn test_factory_multiple_creates() {
    // Factory can create multiple contracts
    let mut env = TestEnv::new();
    let factory = env.deploy_contract("contract_factory");

    let addr1 = env.call_factory_create(&factory).created_address.unwrap();
    let addr2 = env.call_factory_create(&factory).created_address.unwrap();
    let addr3 = env.call_factory_create(&factory).created_address.unwrap();

    assert_ne!(addr1, addr2);
    assert_ne!(addr2, addr3);
}

// =============================================================================
// Contract Self-Destruct Tests
// =============================================================================

#[test]
fn test_selfdestruct() {
    // Contract can self-destruct
    let mut env = TestEnv::new();
    let owner = env.create_account();
    let beneficiary = env.create_account();
    let contract = env.deploy_contract_with_balance("destructible", 1000);

    env.set_caller(owner);
    env.call_function_with_args(&contract, "destroy", vec![beneficiary.as_bytes()]);

    assert_eq!(env.get_code_size(&contract), 0);
    assert_eq!(env.get_balance(&beneficiary), 1000);
}

#[test]
fn test_selfdestruct_unauthorized() {
    // Unauthorized self-destruct fails
    let mut env = TestEnv::new();
    let owner = env.create_account();
    let attacker = env.create_account();
    let contract = env.deploy_contract_with_owner("destructible", &owner);

    env.set_caller(attacker);
    let result = env.call_function_with_args(&contract, "destroy", vec![attacker.as_bytes()]);

    assert!(result.is_err());
}

// =============================================================================
// Event Tests
// =============================================================================

#[test]
fn test_contract_emits_events() {
    // Contract emits events
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_emitter");

    env.call_function(&contract, "doAction");

    let events = env.get_events(&contract);
    assert!(!events.is_empty());
}

#[test]
fn test_indexed_event_parameters() {
    // Events have indexed parameters
    let mut env = TestEnv::new();
    let contract = env.deploy_contract("event_emitter");
    let param = Address::from([0x42u8; 20]);

    env.call_function_with_args(&contract, "emitWithIndexed", vec![param.as_bytes()]);

    let events = env.get_events(&contract);
    assert!(events[0].topics.contains(&pad_address(param)));
}

// =============================================================================
// Helper Functions
// =============================================================================

// All helper functions are imported from tos_tck::test_utils::*
// - compute_contract_address(deployer, nonce) -> Address
// - compute_create2_address(factory, salt, bytecode) -> Address
// - get_bytecode(name) -> Vec<u8>
// - pad_address(addr) -> [u8; 32]
// - encode_u256(value) -> [u8; 32]
