use crate::{
    asset::AssetData, context::NoOpBuildHasher, contract_asset::TokenKey,
    contract_asset::TokenValue, crypto::Hash, versioned_type::VersionedState,
};
use std::collections::HashMap;
use tos_kernel::ValueCell;

#[derive(Debug, Clone)]
pub struct AssetChanges {
    // The asset data
    pub data: (VersionedState, AssetData),
    // The supply of the asset
    pub supply: Option<(VersionedState, u64)>,
}

// Contract cache containing all the changes/cache made by the contract
#[derive(Debug, Clone)]
pub struct ContractCache {
    // The storage of the contract
    // All the changes made by the contract are stored here
    pub storage: HashMap<ValueCell, (VersionedState, Option<ValueCell>)>,
    // The contract balances
    // Those already present are loaded due to the deposits to be added
    // If its none, it means we don't have any balance yet
    pub balances: HashMap<Hash, Option<(VersionedState, u64)>>,
    // Contract-scoped token state (allowance/locks/roles/etc.)
    pub tokens: HashMap<TokenKey, (VersionedState, TokenValue)>,
    // Memory Storage
    // This is shared between all executions of the same contract
    pub memory: HashMap<ValueCell, ValueCell>,
    // Custom events generated by the contract
    pub events: HashMap<u64, Vec<ValueCell>, NoOpBuildHasher>,
}

impl Default for ContractCache {
    fn default() -> Self {
        Self::new()
    }
}

impl ContractCache {
    pub fn new() -> Self {
        Self {
            storage: HashMap::new(),
            balances: HashMap::new(),
            tokens: HashMap::new(),
            memory: HashMap::new(),
            events: HashMap::default(),
        }
    }

    /// Merge storage + token fields from another ContractCache (overlay semantics).
    ///
    /// # Why storage+tokens only?
    ///
    /// TosStorageAdapter ONLY writes to `cache.storage`. Other fields are handled separately:
    /// - `balances`: Managed by chain_state.cache (deposits)
    /// - `events`: Persisted via `add_contract_events()` after execution
    /// - `memory`: Not persisted (transient storage, EIP-1153)
    ///
    /// Using a narrow merge function prevents future bugs where VM might write to
    /// events/balances, causing conflicts with existing persistence paths.
    ///
    /// # Safety
    ///
    /// Callers MUST only call this when execution succeeded (exit_code == Some(0)).
    pub fn merge_overlay_storage_and_tokens(&mut self, other: Self) {
        self.storage.extend(other.storage);
        self.tokens.extend(other.tokens);
        // NOTE: Do NOT merge balances/events/memory here.
        // - balances: already in chain_state.cache from deposits
        // - events: saved via add_contract_events() separately
        // - memory: transient, not persisted
    }

    // Merge the cache with another one
    // pub fn merge(&mut self, other: Self) {
    //     for (key, assets) in other.transfers {
    //         let left_assets = self.transfers.entry(key)
    //             .or_insert_with(HashMap::new);

    //         for (hash, value) in assets {
    //             left_assets.entry(hash)
    //                 .and_modify(|v| *v += value)
    //                 .or_insert(value);
    //         }
    //     }

    //     // Support the deletion of entries
    //     for (key, value) in other.memory {
    //         if value.is_some() {
    //             self.memory.insert(key, value);
    //         } else {
    //             self.memory.remove(&key);
    //         }
    //     }

    //     self.storage.extend(other.storage);
    //     self.balances.extend(other.balances);
    //     self.assets.extend(other.assets);
    // }
}

// #[cfg(test)]
// mod tests {
//     use tos_kernel::Value;
//     use crate::crypto::KeyPair;
//     use super::*;

//     #[test]
//     fn test_merge_cache_balances() {
//         let mut cache1 = ContractCache::new();
//         cache1.balances.insert(Hash::zero(), Some((VersionedState::FetchedAt(0), 100)));

//         let mut cache2 = ContractCache::new();
//         cache2.balances.insert(Hash::zero(), Some((VersionedState::FetchedAt(0), 200)));

//         cache1.merge(cache2);

//         assert_eq!(cache1.balances.len(), 1);
//         assert_eq!(cache1.balances.get(&Hash::zero()), Some(&Some((VersionedState::FetchedAt(0), 200))));
//     }

//     #[test]
//     fn test_merge_cache_storage() {
//         let mut cache1 = ContractCache::new();
//         let key: Constant = Value::String("test".to_owned()).into();
//         cache1.storage.insert(key.clone(), (VersionedState::FetchedAt(0), Some(key.clone())));

//         let value: Constant = Value::String("test1".to_owned()).into();
//         let mut cache2 = ContractCache::new();
//         cache2.storage.insert(key.clone(), (VersionedState::Updated(0), Some(value.clone())));

//         cache1.merge(cache2);

//         assert_eq!(cache1.storage.len(), 1);
//         assert_eq!(cache1.storage.get(&key), Some(&(VersionedState::Updated(0), Some(value))));

//         // Support deleted values
//         let mut cache2 = ContractCache::new();
//         cache2.storage.insert(key.clone(), (VersionedState::Updated(0), None));

//         cache1.merge(cache2);

//         assert_eq!(cache1.storage.len(), 1);
//         assert_eq!(cache1.storage.get(&key), Some(&(VersionedState::Updated(0), None)));
//     }

//     #[test]
//     fn test_merge_cache_memory_storage() {
//         let mut cache1 = ContractCache::new();
//         let key: Constant = Value::String("test".to_owned()).into();
//         let value: Constant = Value::String("test1".to_owned()).into();
//         cache1.memory.insert(key.clone(), Some(value.clone()));

//         let mut cache2 = ContractCache::new();
//         cache2.memory.insert(key, None);
//         cache1.merge(cache2);

//         assert_eq!(cache1.memory.len(), 0);
//     }

//     #[test]
//     fn test_merge_transfers() {
//         let alice = KeyPair::new().get_public_key().compress();
//         let mut cache1 = ContractCache::new();
//         cache1.transfers.insert(alice.clone(), HashMap::new());

//         let mut cache2 = ContractCache::new();
//         let mut assets = HashMap::new();
//         assets.insert(Hash::zero(), 100);
//         cache2.transfers.insert(alice.clone(), assets);

//         cache1.merge(cache2);

//         assert_eq!(1, cache1.transfers[&alice].len());
//     }
// }
