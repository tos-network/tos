//! WebSocket Penetration Testing Suite
//!
//! This module contains comprehensive penetration tests for WebSocket security.
//! Tests cover various attack vectors including DoS, CSRF, and authentication bypass.

#[cfg(test)]
mod websocket_penetration_tests {
    use std::net::{IpAddr, Ipv4Addr};
    use tos_daemon::rpc::ws_security::{
        WebSocketSecurity, WebSocketSecurityConfig, WebSocketSecurityError,
    };

    /// Helper function to create a test security instance
    fn create_test_security(config: WebSocketSecurityConfig) -> WebSocketSecurity {
        WebSocketSecurity::new(config)
    }

    /// Test 1: DoS via Connection Flood
    ///
    /// Attempts to create excessive connections from the same IP address.
    /// Expected: Rate limiter should block connections after the limit.
    #[tokio::test]
    async fn test_dos_via_connection_flood() {
        let config = WebSocketSecurityConfig {
            max_connections_per_ip_per_minute: 10,
            ..Default::default()
        };
        let security = create_test_security(config);
        let attacker_ip = IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100));

        // First 10 connections should succeed
        for i in 0..10 {
            let result = security.check_connection_rate(attacker_ip).await;
            assert!(
                result.is_ok(),
                "Connection {} should succeed (within limit)",
                i + 1
            );
        }

        // Connections 11-20 should be blocked
        for i in 10..20 {
            let result = security.check_connection_rate(attacker_ip).await;
            assert!(
                result.is_err(),
                "Connection {} should be blocked (rate limit exceeded)",
                i + 1
            );

            match result {
                Err(WebSocketSecurityError::ConnectionRateLimitExceeded { ip }) => {
                    assert_eq!(ip, attacker_ip);
                }
                _ => assert!(false, "Expected ConnectionRateLimitExceeded error"),
            }
        }

        println!("✓ DoS via connection flood test passed");
    }

    /// Test 2: DoS via Message Flood
    ///
    /// Sends excessive messages on a single connection.
    /// Expected: Rate limiter should block messages after the limit.
    #[tokio::test]
    async fn test_dos_via_message_flood() {
        let config = WebSocketSecurityConfig {
            max_messages_per_connection_per_second: 5,
            ..Default::default()
        };
        let security = create_test_security(config);
        let connection_id = 12345u64;

        // First 5 messages should succeed
        for i in 0..5 {
            let result = security.check_message_rate(connection_id).await;
            assert!(
                result.is_ok(),
                "Message {} should succeed (within limit)",
                i + 1
            );
        }

        // Messages 6-10 should be blocked
        for i in 5..10 {
            let result = security.check_message_rate(connection_id).await;
            assert!(
                result.is_err(),
                "Message {} should be blocked (rate limit exceeded)",
                i + 1
            );

            match result {
                Err(WebSocketSecurityError::MessageRateLimitExceeded {
                    connection_id: conn_id,
                }) => {
                    assert_eq!(conn_id, connection_id);
                }
                _ => assert!(false, "Expected MessageRateLimitExceeded error"),
            }
        }

        println!("✓ DoS via message flood test passed");
    }

    /// Test 3: DoS via Oversized Message
    ///
    /// Attempts to send a message exceeding the size limit.
    /// Expected: Message should be rejected.
    #[tokio::test]
    async fn test_dos_via_oversized_message() {
        let max_size = 1024 * 1024; // 1MB
        let config = WebSocketSecurityConfig {
            max_message_size: max_size,
            ..Default::default()
        };
        let security = create_test_security(config);

        // Small message should succeed
        let small_size = 512;
        let result = security.validate_message_size(small_size);
        assert!(result.is_ok(), "Small message should be accepted");

        // Exact limit should succeed
        let exact_size = max_size;
        let result = security.validate_message_size(exact_size);
        assert!(result.is_ok(), "Message at exact limit should be accepted");

        // Oversized message should fail
        let oversized = max_size + 1;
        let result = security.validate_message_size(oversized);
        assert!(result.is_err(), "Oversized message should be rejected");

        match result {
            Err(WebSocketSecurityError::MessageTooLarge { size, max }) => {
                assert_eq!(size, oversized);
                assert_eq!(max, max_size);
            }
            _ => assert!(false, "Expected MessageTooLarge error"),
        }

        // Extremely large message (10MB) should fail
        let extremely_large = 10 * 1024 * 1024;
        let result = security.validate_message_size(extremely_large);
        assert!(
            result.is_err(),
            "Extremely large message should be rejected"
        );

        println!("✓ DoS via oversized message test passed");
    }

    /// Test 4: CSRF Protection via Origin Validation
    ///
    /// Tests origin-based CSRF protection.
    /// Expected: Only whitelisted origins should be allowed.
    #[tokio::test]
    async fn test_csrf_protection() {
        let config = WebSocketSecurityConfig {
            allowed_origins: vec![
                "http://localhost:3000".to_string(),
                "https://app.example.com".to_string(),
            ],
            require_auth: true,
            ..Default::default()
        };
        let security = create_test_security(config);

        // Allowed origin should succeed
        let result = security.validate_origin(Some("http://localhost:3000"));
        assert!(result.is_ok(), "Whitelisted origin should be allowed");

        let result = security.validate_origin(Some("https://app.example.com"));
        assert!(result.is_ok(), "Whitelisted origin should be allowed");

        // Evil origin should fail
        let result = security.validate_origin(Some("http://evil.com"));
        assert!(result.is_err(), "Non-whitelisted origin should be blocked");

        match result {
            Err(WebSocketSecurityError::InvalidOrigin { origin }) => {
                assert_eq!(origin, "http://evil.com");
            }
            _ => assert!(false, "Expected InvalidOrigin error"),
        }

        // Missing origin with auth required should fail
        let result = security.validate_origin(None);
        assert!(
            result.is_err(),
            "Missing origin with auth required should fail"
        );

        match result {
            Err(WebSocketSecurityError::MissingOrigin) => {}
            _ => assert!(false, "Expected MissingOrigin error"),
        }

        println!("✓ CSRF protection test passed");
    }

    /// Test 5: Wildcard Origin Acceptance
    ///
    /// Tests that wildcard (*) allows all origins.
    /// Expected: Any origin should be accepted.
    #[tokio::test]
    async fn test_wildcard_origin_acceptance() {
        let config = WebSocketSecurityConfig {
            allowed_origins: vec!["*".to_string()],
            require_auth: false,
            ..Default::default()
        };
        let security = create_test_security(config);

        // Any origin should be accepted
        let origins = vec![
            "http://evil.com",
            "https://malicious.org",
            "http://anywhere.net",
        ];

        for origin in origins {
            let result = security.validate_origin(Some(origin));
            assert!(result.is_ok(), "Wildcard should allow origin: {}", origin);
        }

        println!("✓ Wildcard origin acceptance test passed");
    }

    /// Test 6: Subscription Exhaustion Attack
    ///
    /// Attempts to create excessive subscriptions to exhaust resources.
    /// Expected: Subscription quota should limit the number of subscriptions.
    #[tokio::test]
    async fn test_subscription_exhaustion() {
        let max_subs = 10;
        let config = WebSocketSecurityConfig {
            max_subscriptions_per_connection: max_subs,
            ..Default::default()
        };
        let security = create_test_security(config);

        // First 10 subscriptions should succeed
        for i in 0..max_subs {
            let result = security.check_subscription_quota();
            assert!(result.is_ok(), "Subscription {} should succeed", i + 1);
            security.add_subscription();
        }

        // 11th subscription should fail
        let result = security.check_subscription_quota();
        assert!(result.is_err(), "Subscription quota should be exceeded");

        match result {
            Err(WebSocketSecurityError::SubscriptionQuotaExceeded { count, max }) => {
                assert_eq!(count, max_subs);
                assert_eq!(max, max_subs);
            }
            _ => assert!(false, "Expected SubscriptionQuotaExceeded error"),
        }

        // Remove one subscription and try again
        security.remove_subscription();
        let result = security.check_subscription_quota();
        assert!(
            result.is_ok(),
            "Subscription should succeed after removing one"
        );

        println!("✓ Subscription exhaustion test passed");
    }

    /// Test 7: API Key Authentication
    ///
    /// Tests API key-based authentication.
    /// Expected: Only valid API keys should be accepted.
    #[tokio::test]
    async fn test_api_key_authentication() {
        let config = WebSocketSecurityConfig {
            require_auth: true,
            ..Default::default()
        };
        let security = create_test_security(config);

        // Add a valid API key
        let valid_key = "test-api-key-12345";
        security
            .add_api_key(
                valid_key.to_string(),
                "Test API Key".to_string(),
                vec!["read".to_string(), "write".to_string()],
            )
            .await;

        // Valid key should succeed
        let result = security.verify_api_key(valid_key).await;
        assert!(result.is_ok(), "Valid API key should be accepted");

        let api_key_info = result.unwrap();
        assert_eq!(api_key_info.key, valid_key);
        assert_eq!(api_key_info.description, "Test API Key");
        assert_eq!(api_key_info.permissions.len(), 2);

        // Invalid key should fail
        let result = security.verify_api_key("invalid-key").await;
        assert!(result.is_err(), "Invalid API key should be rejected");

        match result {
            Err(WebSocketSecurityError::InvalidApiKey) => {}
            _ => assert!(false, "Expected InvalidApiKey error"),
        }

        // Remove the key
        security.remove_api_key(valid_key).await;

        // Removed key should fail
        let result = security.verify_api_key(valid_key).await;
        assert!(result.is_err(), "Removed API key should be rejected");

        println!("✓ API key authentication test passed");
    }

    /// Test 8: Connection Cleanup After Removal
    ///
    /// Tests that connection tracking is properly cleaned up.
    /// Expected: Removed connections should no longer be tracked.
    #[tokio::test]
    async fn test_connection_cleanup() {
        let config = WebSocketSecurityConfig {
            max_messages_per_connection_per_second: 5,
            ..Default::default()
        };
        let security = create_test_security(config);
        let connection_id = 99999u64;

        // Send some messages
        for _ in 0..3 {
            let _ = security.check_message_rate(connection_id).await;
        }

        // Remove the connection
        security.remove_connection(connection_id).await;

        // After removal, counter should be reset
        // This is verified by cleanup task, but we can test that removal doesn't panic
        security.cleanup().await;

        println!("✓ Connection cleanup test passed");
    }

    /// Test 9: Distributed DoS Protection
    ///
    /// Tests protection against distributed attacks from multiple IPs.
    /// Expected: Each IP should be rate limited independently.
    #[tokio::test]
    async fn test_distributed_dos_protection() {
        let config = WebSocketSecurityConfig {
            max_connections_per_ip_per_minute: 5,
            ..Default::default()
        };
        let security = create_test_security(config);

        // Simulate 10 different IPs
        let attacker_ips: Vec<IpAddr> = (1..=10)
            .map(|i| IpAddr::V4(Ipv4Addr::new(192, 168, 1, i as u8)))
            .collect();

        // Each IP can make 5 connections
        for ip in &attacker_ips {
            for _ in 0..5 {
                let result = security.check_connection_rate(*ip).await;
                assert!(result.is_ok(), "Connection should succeed for IP: {}", ip);
            }

            // 6th connection should fail
            let result = security.check_connection_rate(*ip).await;
            assert!(result.is_err(), "6th connection should fail for IP: {}", ip);
        }

        println!("✓ Distributed DoS protection test passed");
    }

    /// Test 10: Rate Limit Reset After Time Window
    ///
    /// Tests that rate limits reset after the time window expires.
    /// Expected: After waiting, new connections/messages should be allowed.
    #[tokio::test]
    async fn test_rate_limit_reset() {
        let config = WebSocketSecurityConfig {
            max_messages_per_connection_per_second: 2,
            ..Default::default()
        };
        let security = create_test_security(config);
        let connection_id = 54321u64;

        // Send 2 messages (max)
        for _ in 0..2 {
            let result = security.check_message_rate(connection_id).await;
            assert!(result.is_ok(), "Message should succeed");
        }

        // 3rd message should fail
        let result = security.check_message_rate(connection_id).await;
        assert!(result.is_err(), "3rd message should be blocked");

        // Wait for rate limit window to reset (1 second + buffer)
        tokio::time::sleep(tokio::time::Duration::from_millis(1100)).await;

        // After reset, message should succeed
        let result = security.check_message_rate(connection_id).await;
        assert!(result.is_ok(), "Message should succeed after reset");

        println!("✓ Rate limit reset test passed");
    }

    /// Test 11: Concurrent Connection Attempts
    ///
    /// Tests thread safety of rate limiting under concurrent load.
    /// Expected: Rate limiter should handle concurrent requests correctly.
    #[tokio::test]
    async fn test_concurrent_connection_attempts() {
        let config = WebSocketSecurityConfig {
            max_connections_per_ip_per_minute: 20,
            ..Default::default()
        };
        let security = std::sync::Arc::new(create_test_security(config));
        let ip = IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1));

        // Spawn 30 concurrent connection attempts
        let mut handles = vec![];
        for _ in 0..30 {
            let security_clone = std::sync::Arc::clone(&security);
            let handle =
                tokio::spawn(async move { security_clone.check_connection_rate(ip).await });
            handles.push(handle);
        }

        // Wait for all attempts to complete
        let results: Vec<_> = futures::future::join_all(handles).await;

        // Count successes and failures
        let successes = results
            .iter()
            .filter(|r| r.as_ref().unwrap().is_ok())
            .count();
        let failures = results
            .iter()
            .filter(|r| r.as_ref().unwrap().is_err())
            .count();

        // Should have exactly 20 successes and 10 failures
        assert_eq!(successes, 20, "Should have 20 successful connections");
        assert_eq!(failures, 10, "Should have 10 blocked connections");

        println!("✓ Concurrent connection attempts test passed");
    }

    /// Integration Test: Full Attack Scenario
    ///
    /// Simulates a comprehensive attack combining multiple vectors.
    /// Expected: All security mechanisms should work together.
    #[tokio::test]
    async fn test_full_attack_scenario() {
        let config = WebSocketSecurityConfig {
            allowed_origins: vec!["http://legitimate.com".to_string()],
            require_auth: true,
            max_message_size: 1024,
            max_subscriptions_per_connection: 5,
            max_connections_per_ip_per_minute: 10,
            max_messages_per_connection_per_second: 3,
        };
        let security = create_test_security(config);
        let attacker_ip = IpAddr::V4(Ipv4Addr::new(192, 168, 1, 66));

        // Attack 1: Try evil origin
        let result = security.validate_origin(Some("http://evil.com"));
        assert!(result.is_err(), "Evil origin should be blocked");

        // Attack 2: Connection flood
        for _ in 0..10 {
            let _ = security.check_connection_rate(attacker_ip).await;
        }
        let result = security.check_connection_rate(attacker_ip).await;
        assert!(result.is_err(), "Connection flood should be blocked");

        // Attack 3: Oversized message
        let result = security.validate_message_size(2048);
        assert!(result.is_err(), "Oversized message should be blocked");

        // Attack 4: Subscription exhaustion
        for _ in 0..5 {
            security.add_subscription();
        }
        let result = security.check_subscription_quota();
        assert!(result.is_err(), "Subscription exhaustion should be blocked");

        println!("✓ Full attack scenario test passed");
        println!("✓ All penetration tests completed successfully!");
    }
}
