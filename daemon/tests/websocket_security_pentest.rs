//! WebSocket Penetration Testing Integration Test
//!
//! This file provides a standalone integration test for WebSocket security.

#![allow(clippy::disallowed_methods)]

mod websocket_penetration_tests {
    use std::net::{IpAddr, Ipv4Addr};
    use tos_daemon::rpc::websocket::{WebSocketSecurity, WebSocketSecurityConfig};

    fn create_test_security(config: WebSocketSecurityConfig) -> WebSocketSecurity {
        WebSocketSecurity::new(config)
    }

    #[tokio::test]
    async fn test_dos_via_connection_flood() {
        let config = WebSocketSecurityConfig {
            max_connections_per_ip_per_minute: 10,
            ..Default::default()
        };
        let security = create_test_security(config);
        let attacker_ip = IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100));

        for i in 0..10 {
            let result = security.check_connection_rate(attacker_ip).await;
            assert!(
                result.is_ok(),
                "Connection {} should succeed (within limit)",
                i + 1
            );
        }

        for i in 10..20 {
            let result = security.check_connection_rate(attacker_ip).await;
            assert!(
                result.is_err(),
                "Connection {} should be blocked (rate limit exceeded)",
                i + 1
            );
        }

        println!("✓ DoS via connection flood test passed");
    }

    #[tokio::test]
    async fn test_dos_via_message_flood() {
        let config = WebSocketSecurityConfig {
            max_messages_per_connection_per_second: 5,
            ..Default::default()
        };
        let security = create_test_security(config);
        let connection_id = 12345u64;

        for i in 0..5 {
            let result = security.check_message_rate(connection_id).await;
            assert!(
                result.is_ok(),
                "Message {} should succeed (within limit)",
                i + 1
            );
        }

        for i in 5..10 {
            let result = security.check_message_rate(connection_id).await;
            assert!(
                result.is_err(),
                "Message {} should be blocked (rate limit exceeded)",
                i + 1
            );
        }

        println!("✓ DoS via message flood test passed");
    }

    #[tokio::test]
    async fn test_dos_via_oversized_message() {
        let max_size = 1024 * 1024;
        let config = WebSocketSecurityConfig {
            max_message_size: max_size,
            ..Default::default()
        };
        let security = create_test_security(config);

        assert!(security.validate_message_size(512).is_ok());
        assert!(security.validate_message_size(max_size).is_ok());
        assert!(security.validate_message_size(max_size + 1).is_err());
        assert!(security.validate_message_size(10 * 1024 * 1024).is_err());

        println!("✓ DoS via oversized message test passed");
    }

    #[tokio::test]
    async fn test_csrf_protection() {
        let config = WebSocketSecurityConfig {
            allowed_origins: vec![
                "http://localhost:3000".to_string(),
                "https://app.example.com".to_string(),
            ],
            require_auth: true,
            ..Default::default()
        };
        let security = create_test_security(config);

        assert!(security
            .validate_origin(Some("http://localhost:3000"))
            .is_ok());
        assert!(security
            .validate_origin(Some("https://app.example.com"))
            .is_ok());
        assert!(security.validate_origin(Some("http://evil.com")).is_err());
        assert!(security.validate_origin(None).is_err());

        println!("✓ CSRF protection test passed");
    }

    #[tokio::test]
    async fn test_wildcard_origin_acceptance() {
        let config = WebSocketSecurityConfig {
            allowed_origins: vec!["*".to_string()],
            require_auth: false,
            ..Default::default()
        };
        let security = create_test_security(config);

        for origin in &[
            "http://evil.com",
            "https://malicious.org",
            "http://anywhere.net",
        ] {
            assert!(security.validate_origin(Some(origin)).is_ok());
        }

        println!("✓ Wildcard origin acceptance test passed");
    }

    #[tokio::test]
    async fn test_subscription_exhaustion() {
        let max_subs = 10;
        let config = WebSocketSecurityConfig {
            max_subscriptions_per_connection: max_subs,
            ..Default::default()
        };
        let security = create_test_security(config);

        for _i in 0..max_subs {
            assert!(security.check_subscription_quota().is_ok());
            security.add_subscription();
        }

        assert!(security.check_subscription_quota().is_err());

        security.remove_subscription();
        assert!(security.check_subscription_quota().is_ok());

        println!("✓ Subscription exhaustion test passed");
    }

    #[tokio::test]
    async fn test_api_key_authentication() {
        let config = WebSocketSecurityConfig {
            require_auth: true,
            ..Default::default()
        };
        let security = create_test_security(config);

        let valid_key = "test-api-key-12345";
        security
            .add_api_key(
                valid_key.to_string(),
                "Test API Key".to_string(),
                vec!["read".to_string(), "write".to_string()],
            )
            .await;

        assert!(security.verify_api_key(valid_key).await.is_ok());
        assert!(security.verify_api_key("invalid-key").await.is_err());

        security.remove_api_key(valid_key).await;
        assert!(security.verify_api_key(valid_key).await.is_err());

        println!("✓ API key authentication test passed");
    }

    #[tokio::test]
    async fn test_connection_cleanup() {
        let config = WebSocketSecurityConfig {
            max_messages_per_connection_per_second: 5,
            ..Default::default()
        };
        let security = create_test_security(config);
        let connection_id = 99999u64;

        for _ in 0..3 {
            let _ = security.check_message_rate(connection_id).await;
        }

        security.remove_connection(connection_id).await;
        security.cleanup().await;

        println!("✓ Connection cleanup test passed");
    }

    #[tokio::test]
    async fn test_distributed_dos_protection() {
        let config = WebSocketSecurityConfig {
            max_connections_per_ip_per_minute: 5,
            ..Default::default()
        };
        let security = create_test_security(config);

        let attacker_ips: Vec<IpAddr> = (1..=10)
            .map(|i| IpAddr::V4(Ipv4Addr::new(192, 168, 1, i as u8)))
            .collect();

        for ip in &attacker_ips {
            for _ in 0..5 {
                assert!(security.check_connection_rate(*ip).await.is_ok());
            }
            assert!(security.check_connection_rate(*ip).await.is_err());
        }

        println!("✓ Distributed DoS protection test passed");
    }

    #[tokio::test]
    async fn test_rate_limit_reset() {
        let config = WebSocketSecurityConfig {
            max_messages_per_connection_per_second: 2,
            ..Default::default()
        };
        let security = create_test_security(config);
        let connection_id = 54321u64;

        for _ in 0..2 {
            assert!(security.check_message_rate(connection_id).await.is_ok());
        }
        assert!(security.check_message_rate(connection_id).await.is_err());

        tokio::time::sleep(tokio::time::Duration::from_millis(1100)).await;

        assert!(security.check_message_rate(connection_id).await.is_ok());

        println!("✓ Rate limit reset test passed");
    }

    #[tokio::test]
    async fn test_concurrent_connection_attempts() {
        let config = WebSocketSecurityConfig {
            max_connections_per_ip_per_minute: 20,
            ..Default::default()
        };
        let security = std::sync::Arc::new(create_test_security(config));
        let ip = IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1));

        let mut handles = vec![];
        for _ in 0..30 {
            let security_clone = std::sync::Arc::clone(&security);
            let handle =
                tokio::spawn(async move { security_clone.check_connection_rate(ip).await });
            handles.push(handle);
        }

        let results: Vec<_> = futures::future::join_all(handles).await;

        let successes = results
            .iter()
            .filter(|r| r.as_ref().unwrap().is_ok())
            .count();
        let failures = results
            .iter()
            .filter(|r| r.as_ref().unwrap().is_err())
            .count();

        assert_eq!(successes, 20);
        assert_eq!(failures, 10);

        println!("✓ Concurrent connection attempts test passed");
    }

    #[tokio::test]
    async fn test_full_attack_scenario() {
        let config = WebSocketSecurityConfig {
            allowed_origins: vec!["http://legitimate.com".to_string()],
            require_auth: true,
            max_message_size: 1024,
            max_subscriptions_per_connection: 5,
            max_connections_per_ip_per_minute: 10,
            max_messages_per_connection_per_second: 3,
        };
        let security = create_test_security(config);
        let attacker_ip = IpAddr::V4(Ipv4Addr::new(192, 168, 1, 66));

        assert!(security.validate_origin(Some("http://evil.com")).is_err());

        for _ in 0..10 {
            let _ = security.check_connection_rate(attacker_ip).await;
        }
        assert!(security.check_connection_rate(attacker_ip).await.is_err());

        assert!(security.validate_message_size(2048).is_err());

        for _ in 0..5 {
            security.add_subscription();
        }
        assert!(security.check_subscription_quota().is_err());

        println!("✓ Full attack scenario test passed");
        println!("✓ All 12 penetration tests completed successfully!");
    }
}
